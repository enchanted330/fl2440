diff -Nuar u-boot-2010.09/arch/arm/cpu/arm920t/s3c24x0/speed.c u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/s3c24x0/speed.c
--- u-boot-2010.09/arch/arm/cpu/arm920t/s3c24x0/speed.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/s3c24x0/speed.c	2013-04-25 17:06:35.273626748 +0800
@@ -64,6 +64,12 @@
 	p = ((r & 0x003F0) >> 4) + 2;
 	s = r & 0x3;
 
+#if defined(CONFIG_S3C2440) /*Add by guowenxue*/
+  if (pllreg == MPLL)
+    return ((CONFIG_SYS_CLK_FREQ * m * 2) /(p << s));
+  else if (pllreg == UPLL)
+#endif /*Add end*/
+
 	return (CONFIG_SYS_CLK_FREQ * m) / (p << s);
 }
 
@@ -78,7 +84,23 @@
 {
 	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
 
-	return (readl(&clk_power->CLKDIVN) & 2) ? get_FCLK() / 2 : get_FCLK();
+//	return (readl(&clk_power->CLKDIVN) & 2) ? get_FCLK() / 2 : get_FCLK();
+#if defined(CONFIG_S3C2440) /*Modify by guowenxue*/
+    if (readl(&clk_power->CLKDIVN) & 0x6) 
+    { 
+          if ((readl(&clk_power->CLKDIVN) & 0x6)==2) 
+                  return(get_FCLK()/2); 
+          if ((readl(&clk_power->CLKDIVN) & 0x6)==6) 
+                  return((readl(&clk_power->CAMDIVN) & 0x100) ? get_FCLK()/6 : get_FCLK()/3); 
+          if ((readl(&clk_power->CLKDIVN) & 0x6)==4) 
+                  return((readl(&clk_power->CAMDIVN) & 0x200) ? get_FCLK()/8 : get_FCLK()/4); 
+          return(get_FCLK()); 
+    } 
+    else 
+          return(get_FCLK()); 
+#else 
+    return((readl(&clk_power->CLKDIVN) & 0x2) ? get_FCLK()/2 : get_FCLK()); 
+#endif /*Modify end*/
 }
 
 /* return PCLK frequency */
diff -Nuar u-boot-2010.09/arch/arm/cpu/arm920t/s3c24x0/timer.c u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/s3c24x0/timer.c
--- u-boot-2010.09/arch/arm/cpu/arm920t/s3c24x0/timer.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/s3c24x0/timer.c	2013-04-25 17:06:35.273626748 +0800
@@ -181,8 +181,10 @@
 	tbclk = timer_load_val * 100;
 #elif defined(CONFIG_SBC2410X) || \
       defined(CONFIG_SMDK2410) || \
-      defined(CONFIG_VCMA9)
-	tbclk = CONFIG_SYS_HZ;
+      defined(CONFIG_SD2410) || \
+      defined(CONFIG_S3C2440) || \
+      defined(CONFIG_VCMA9) 
+    tbclk = CONFIG_SYS_HZ;
 #else
 #	error "tbclk not configured"
 #endif
diff -Nuar u-boot-2010.09/arch/arm/cpu/arm920t/start.S u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/start.S
--- u-boot-2010.09/arch/arm/cpu/arm920t/start.S	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/start.S	2013-04-25 17:06:35.281436816 +0800
@@ -114,8 +114,8 @@
 	orr	r0, r0, #0xd3
 	msr	cpsr, r0
 
-	bl	coloured_LED_init
-	bl	red_LED_on
+@	bl	coloured_LED_init
+@	bl	red_LED_on
 
 #if	defined(CONFIG_AT91RM9200DK) || defined(CONFIG_AT91RM9200EK)
 	/*
@@ -131,7 +131,7 @@
 	bne	copyex
 #endif
 
-#ifdef CONFIG_S3C24X0
+#if 0 /*We init S3C24XX in board/kkernel/xxxx/lowlevel_init.S, which called in cpu_init_crit */
 	/* turn off the watchdog */
 
 # if defined(CONFIG_S3C2400)
@@ -177,12 +177,87 @@
 #endif
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
+    /*Judgement the u-boot is running in RAM or not, if it's already in RAM, 
+      then jump to stack_setup directly*/
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	cmp	r0, r1			/* don't reloc during debug         */
 	beq	stack_setup
 
+#ifdef CONFIG_S3C24X0
+    /* Check it's boot from Norflash or Nandflash:
+     * If it's boot from Nandflash on S3C24X0 CPU, then the 4K internal SRAM(iSRAM) will 
+     * mapped to both  address 0x4000003C and 0x0000003C. Read this start.S upside source 
+     * code can see, the data in offset address 0x3C from the iSRAM should be 0xdeadbeef
+     * (.balignl 16,0xdeadbeef). So if it's boot from Nandflash, if we modify the address 0x4000003C 
+     * value to 0; then 0x0000003C value should be 0. For they are both in the iSRAM;
+     * But if it's boot from Norflash, then the iSRAM is not mapped to 0x0000003C. So if modify address 
+     * 0x4000003C(it's in iSRAM) value, the 0x0000003C(it's in Norflash) should be still 0xdeadbeef.
+     */ 
+    ldr r1, =( (4<<28)|(3<<4)|(3<<2) )      /* address of Internal SRAM  0x4000003C*/
+    mov r0, #0      /* r0 = 0 */
+    str r0, [r1]
+
+    mov r1, #0x3c       /* address of men  0x0000003C*/
+    ldr r0, [r1]
+    cmp r0, #0
+    bne NORFLASH_BOOT
+
+    /* recovery address 0x0000003C date*/
+    ldr r0, =(0xdeadbeef)
+    ldr r1, =( (4<<28)|(3<<4)|(3<<2) )
+    str r0, [r1]
+
+    #define LENGTH_UBOOT    0x60000
+NANDFLASH_BOOT:
+    /*Get ready to call C functions for nand_read_ll()*/
+    ldr sp, DW_STACK_START  @ setup stack pointer
+    mov fp, #0  @ no previous frame, so fp=0
+
+    /* Read u-boot from Nandflash to SDRAM address $TEXT_BASE */
+    ldr r0, =TEXT_BASE     /*nand_read_ll() 1st argument*/
+    mov r1, #0x0           /*nand_read_ll() 2nd argument*/
+    mov r2, #LENGTH_UBOOT  /*nand_read_ll() 3rd argument*/
+    bl  nand_read_ll
+    tst r0, #0x0           /*Check nand_read_ll() return value*/
+
+    bne infinite_loop     /*nand_read_ll() not return 0, then goto dead loop*/
+
+nand_read_ok:
+    /*Then verify the read data validation*/
+    mov r0, #0             /*The first 4K data in internal SRAM*/
+    ldr r1, =TEXT_BASE     /*The first 4K data read from Nandflash in SDRAM*/
+    mov r2, #0x400         /*The compare data length*/
+
+compare_next_byte:
+    ldr r3, [r0], #4
+    ldr r4, [r1], #4
+    teq r3, r4
+    bne infinite_loop 
+
+    subs    r2, r2, #4
+    beq stack_setup
+    bne compare_next_byte
+    
+infinite_loop:
+    b   infinite_loop
+
+#endif
+
+#define GPBDAT                      0x56000014
+NORFLASH_BOOT:                /* relocate U-Boot from Flash to RAM */
+    ldr     r2, =GPBDAT
+    ldr     r3, [r2]
+    bic     r3, r3, #0x40     /*Set bit 6 as low level, Turn On LED*/
+    str     r3, [r2]
+
+    ldr r1, =(0xdeadbeef)
+    cmp r0, r1
+    bne infinite_loop
+
+    adr r0, _start          /* r0 <- current position of code */
+    ldr r1, _TEXT_BASE      /* test if we run from flash or RAM */
 	ldr	r2, _armboot_start
 	ldr	r3, _bss_start
 	sub	r2, r3, r2		/* r2 <- size of armboot            */
@@ -195,6 +270,11 @@
 	ble	copy_loop
 #endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
+    ldr     r2, =GPBDAT
+    ldr     r3, [r2]
+    orr     r3, r3, #0x40     /*Set bit 6 as low level, Turn On LED*/
+    str     r3, [r2]
+
 	/* Set up the stack						    */
 stack_setup:
 	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
@@ -216,10 +296,20 @@
 	cmp	r0, r1
 	ble	clbss_l
 
+    ldr     r2, =GPBDAT
+    ldr     r3, [r2]
+    bic     r3, r3, #0x100     /*Set bit 8 as low level, Turn On LED*/
+    str     r3, [r2]
 	ldr	pc, _start_armboot
 
 _start_armboot:	.word start_armboot
 
+#ifdef CONFIG_S3C24X0
+#define STACK_BASE 0x33f00000
+#define STACK_SIZE 0x10000
+    .align  2
+DW_STACK_START: .word   STACK_BASE+STACK_SIZE-4
+#endif
 
 /*
  *************************************************************************
diff -Nuar u-boot-2010.09/arch/arm/cpu/arm920t/u-boot.lds u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/u-boot.lds
--- u-boot-2010.09/arch/arm/cpu/arm920t/u-boot.lds	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/cpu/arm920t/u-boot.lds	2013-04-25 17:06:35.281436816 +0800
@@ -40,6 +40,8 @@
 	.text :
 	{
 		arch/arm/cpu/arm920t/start.o	(.text)
+        board/kkernel/fl2440/lowlevel_init.o    (.text)
+        board/kkernel/fl2440/nand_read.o    (.text)
 		*(.text)
 	}
 
diff -Nuar u-boot-2010.09/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h u-boot-2010.09-fl2440/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h
--- u-boot-2010.09/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h	2013-04-25 17:06:35.282437576 +0800
@@ -22,6 +22,8 @@
 	#include <asm/arch/s3c2400.h>
 #elif defined CONFIG_S3C2410
 	#include <asm/arch/s3c2410.h>
+#elif defined CONFIG_S3C2440
+    #include <asm/arch/s3c2410.h> /*Add by guowenxue*/
 #else
 	#error Please define the s3c24x0 cpu type
 #endif
diff -Nuar u-boot-2010.09/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h u-boot-2010.09-fl2440/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h
--- u-boot-2010.09/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h	2013-04-25 17:06:35.282437576 +0800
@@ -78,7 +78,7 @@
 	u32	PRIORITY;
 	u32	INTPND;
 	u32	INTOFFSET;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	SUBSRCPND;
 	u32	INTSUBMSK;
 #endif
@@ -88,11 +88,11 @@
 /* DMAS (see manual chapter 8) */
 struct s3c24x0_dma {
 	u32	DISRC;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	DISRCC;
 #endif
 	u32	DIDST;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	DIDSTC;
 #endif
 	u32	DCON;
@@ -103,7 +103,7 @@
 #ifdef CONFIG_S3C2400
 	u32	res[1];
 #endif
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	res[7];
 #endif
 };
@@ -122,6 +122,9 @@
 	u32	CLKCON;
 	u32	CLKSLOW;
 	u32	CLKDIVN;
+#if defined (CONFIG_S3C2440)
+    u32 CAMDIVN;
+#endif
 };
 
 
@@ -141,7 +144,7 @@
 	u32	res[8];
 	u32	DITHMODE;
 	u32	TPAL;
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	LCDINTPND;
 	u32	LCDSRCPND;
 	u32	LCDINTMSK;
@@ -149,7 +152,7 @@
 #endif
 };
 
-
+#if defined(CONFIG_S3C2410)
 /* NAND FLASH (see S3C2410 manual chapter 6) */
 struct s3c2410_nand {
 	u32	NFCONF;
@@ -159,6 +162,28 @@
 	u32	NFSTAT;
 	u32	NFECC;
 };
+#endif
+#if defined (CONFIG_S3C2440)
+/* NAND FLASH (see S3C2440 manual chapter 6) */
+struct s3c2410_nand {
+    u32 NFCONF; 
+    u32 NFCONT; 
+    u32 NFCMD; 
+    u32 NFADDR; 
+    u32 NFDATA; 
+    u32 NFMECCD0; 
+    u32 NFMECCD1; 
+    u32 NFSECCD; 
+    u32 NFSTAT; 
+    u32 NFESTAT0; 
+    u32 NFESTAT1; 
+    u32 NFMECC0; 
+    u32 NFMECC1; 
+    u32 NFSECC; 
+    u32 NFSBLK; 
+    u32 NFEBLK; 
+};
+#endif
 
 
 /* UART (see manual chapter 11) */
@@ -298,13 +323,13 @@
 	u8	INDEX_REG;
 	u8	res9[7];
 	u8	MAXP_REG;
-	u8	res10[7];
+	u8	res10[3];
 	u8	EP0_CSR_IN_CSR1_REG;
 	u8	res11[3];
 	u8	IN_CSR2_REG;
-	u8	res12[3];
+	u8	res12[7];
 	u8	OUT_CSR1_REG;
-	u8	res13[7];
+	u8	res13[3];
 	u8	OUT_CSR2_REG;
 	u8	res14[3];
 	u8	OUT_FIFO_CNT1_REG;
@@ -312,8 +337,14 @@
 	u8	OUT_FIFO_CNT2_REG;
 	u8	res16[3];
 #endif /*  __BIG_ENDIAN */
+    u32 res17[8];
 	struct s3c24x0_usb_dev_fifos	fifo[5];
-	struct s3c24x0_usb_dev_dmas	dma[5];
+    u32 res18[11];
+    struct s3c24x0_usb_dev_dmas ep1;
+    struct s3c24x0_usb_dev_dmas ep2; 
+    u8  res19[16]; 
+    struct s3c24x0_usb_dev_dmas ep3; 
+    struct s3c24x0_usb_dev_dmas ep4;
 };
 
 
@@ -397,7 +428,7 @@
 	u32	MISCCR;
 	u32	EXTINT;
 #endif
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	u32	GPACON;
 	u32	GPADAT;
 	u32	res1[2];
@@ -446,6 +477,14 @@
 	u32	GSTATUS2;
 	u32	GSTATUS3;
 	u32	GSTATUS4;
+#if defined (CONFIG_S3C2440)
+    u32 res9[3]; 
+    u32 MSLCON; 
+    u32 GPJCON; 
+    u32 GPJDAT; 
+    u32 GPJUP;
+#endif
+
 #endif
 };
 
@@ -639,6 +678,8 @@
 	u32	SDIDCNT;
 	u32	SDIDSTA;
 	u32	SDIFSTA;
+#if defined(CONFIG_S3C2410)
+/*
 #ifdef __BIG_ENDIAN
 	u8	res[3];
 	u8	SDIDAT;
@@ -646,7 +687,13 @@
 	u8	SDIDAT;
 	u8	res[3];
 #endif
+*/
+    u32 SDIDAT;
 	u32	SDIIMSK;
+#elif defined(CONFIG_S3C2440)
+    u32 SDIIMSK; 
+    u32 SDIDAT;
+#endif
 };
 
 #endif /*__S3C24X0_H__*/
diff -Nuar u-boot-2010.09/arch/arm/lib/board.c u-boot-2010.09-fl2440/arch/arm/lib/board.c
--- u-boot-2010.09/arch/arm/lib/board.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/lib/board.c	2013-04-25 17:06:35.282437576 +0800
@@ -87,6 +87,7 @@
 #endif
 
 
+#if 0
 /************************************************************************
  * Coloured LED functionality
  ************************************************************************
@@ -110,6 +111,7 @@
 void blue_LED_on(void) __attribute__((weak, alias("__blue_LED_on")));
 void inline __blue_LED_off(void) {}
 void blue_LED_off(void) __attribute__((weak, alias("__blue_LED_off")));
+#endif
 
 /************************************************************************
  * Init Utilities							*
@@ -136,6 +138,7 @@
 static int display_banner (void)
 {
 	printf ("\n\n%s\n\n", version_string);
+        printf("Modified by guowenxue for s3c2440/s3c2410 board.\n");
 	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
 	       _armboot_start, _bss_start, _bss_end);
 #ifdef CONFIG_MODEM_SUPPORT
diff -Nuar u-boot-2010.09/arch/arm/lib/bootm.c u-boot-2010.09-fl2440/arch/arm/lib/bootm.c
--- u-boot-2010.09/arch/arm/lib/bootm.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/arch/arm/lib/bootm.c	2013-04-25 17:06:35.283437655 +0800
@@ -65,6 +65,7 @@
 		return 1;
 
 	theKernel = (void (*)(int, int, uint))images->ep;
+    printf("Image entry point=%p\n", images->ep);
 
 	s = getenv ("machid");
 	if (s) {
diff -Nuar u-boot-2010.09/board/kkernel/fl2440/config.mk u-boot-2010.09-fl2440/board/kkernel/fl2440/config.mk
--- u-boot-2010.09/board/kkernel/fl2440/config.mk	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/fl2440/config.mk	2013-04-25 17:06:35.283437655 +0800
@@ -0,0 +1,23 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+
+TEXT_BASE = 0x33F80000
diff -Nuar u-boot-2010.09/board/kkernel/fl2440/fl2440.c u-boot-2010.09-fl2440/board/kkernel/fl2440/fl2440.c
--- u-boot-2010.09/board/kkernel/fl2440/fl2440.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/fl2440/fl2440.c	2013-04-25 17:06:35.283437655 +0800
@@ -0,0 +1,328 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <video_fb.h> /*Add by guowenxue*/
+
+#if defined(CONFIG_CMD_NAND)
+#include <linux/mtd/nand.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+
+#if defined(CONFIG_S3C2410)
+/* Fout = 202.8MHz */
+#define M_MDIV  0xA1
+#define M_PDIV  0x3
+#define M_SDIV  0x1
+#endif
+
+#if defined(CONFIG_S3C2440)
+/* Fout = 405MHz */
+#define M_MDIV 0x7f 
+#define M_PDIV 0x2
+#define M_SDIV 0x1
+#endif
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+
+#if defined(CONFIG_S3C2410)
+#define U_M_MDIV    0x48
+#define U_M_PDIV    0x3
+#endif
+
+#if defined(CONFIG_S3C2440)
+#define U_M_MDIV 0x38
+#define U_M_PDIV 0x2
+#endif
+
+#define U_M_SDIV	0x2
+#endif
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+			  "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+#ifdef CONFIG_FL2440_BEEP /* Add by guowenxue, 2012.10.04 */
+#define BEEP         0    /* Buzzer use GPB0 */
+#define DELAY_TIME   10000000
+
+void turn_beep(void)
+{
+    int                  count = 2;
+    struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+    gpio->GPBCON = (gpio->GPBCON|0x3)&0x1; /*  Set GPB0 as GPIO output mode(0x01) */
+
+    while(count--)
+    {
+        gpio->GPBCON = (gpio->GPBCON|0x3)&0x1; /*  Set GPB0 as GPIO output mode(0x01) */
+
+        gpio->GPBDAT &= ~(1<<BEEP);  /*  Set Beep GPIO as low level */
+        delay(DELAY_TIME);
+
+        gpio->GPBDAT |= 1<<BEEP;     /*  Set Beep GPIO as high level */
+        delay(DELAY_TIME);
+
+        gpio->GPBCON &= ~0x3; /*  Set GPB0 as GPIO input mode(0x00) */
+    }
+
+    return ;
+}
+#endif
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	struct s3c24x0_clock_power * const clk_power =
+					s3c24x0_get_base_clock_power();
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+	gpio->GPACON = 0x007FFFFF;
+
+#if defined(CONFIG_FL2440)
+    gpio->GPBCON = 0x00295550;
+#else
+	gpio->GPBCON = 0x00044554;
+#endif
+
+	gpio->GPBUP = 0x000007FF;
+
+#if defined(CONFIG_FL2440)
+    gpio->GPCCON = 0xAAAAA6AA;
+    gpio->GPCDAT &= ~(1<<5);
+#else
+	gpio->GPCCON = 0xAAAAAAAA;
+#endif
+	gpio->GPCUP = 0xFFFFFFFF;
+	gpio->GPDCON = 0xAAAAAAAA;
+	gpio->GPDUP = 0xFFFFFFFF;
+
+	gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+	gpio->GPFCON = 0x000055AA;
+	gpio->GPFUP = 0x000000FF;
+	gpio->GPGCON = 0xFF95FF3A;
+	gpio->GPGUP = 0x0000FFFF;
+	gpio->GPHCON = 0x0016FAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	gpio->EXTINT0=0x22222222;
+	gpio->EXTINT1=0x22222222;
+	gpio->EXTINT2=0x22222222;
+
+#if defined(CONFIG_S3C2410)
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+#endif
+
+#if defined(CONFIG_S3C2440)
+    /* arch number of S3C2440-Board */
+    gd->bd->bi_arch_number = MACH_TYPE_MINI2440 ; /*Use MINI2440 board*/
+#endif
+
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+#if defined(CONFIG_FL2440_LED)
+    gpio->GPBDAT = 0x00000181;
+#endif
+#ifdef CONFIG_FL2440_BEEP /* Add by guowenxue, 2012.10.04 */
+    turn_beep();
+#endif
+
+	return 0;
+}
+
+#ifdef  CONFIG_FL2440_CONSOLE_LCD /*This part add by guowenxue*/ 
+#define MVAL        (0)
+#define MVAL_USED   (0)     //0=each frame   1=rate by MVAL
+#define INVVDEN     (1)     //0=normal       1=inverted
+#define BSWP        (0)     //Byte swap control
+#define HWSWP       (1)     //Half word swap control
+
+
+//TFT 240320
+#define LCD_XSIZE_TFT_240320    (240)   
+#define LCD_YSIZE_TFT_240320    (320)
+
+//TFT240320
+#define HOZVAL_TFT_240320   (LCD_XSIZE_TFT_240320-1)
+#define LINEVAL_TFT_240320  (LCD_YSIZE_TFT_240320-1)
+
+//Timing parameter for NEC3.5"
+#define VBPD_240320     (3)     
+#define VFPD_240320     (10)
+#define VSPW_240320     (1)
+
+#define HBPD_240320     (5)
+#define HFPD_240320     (2)
+#define HSPW_240320_NEC     (36)  //Adjust the horizontal displacement of the screen :tekkamanninja@
+163.com
+#define HSPW_240320_TD      (23)  //64MB nand mini2440 is 36 ,128MB is 23
+                      //+ ??~Z -->    - : <--
+#define CLKVAL_TFT_240320   (3)     
+//FCLK=101.25MHz,HCLK=50.625MHz,VCLK=6.33MHz
+
+void board_video_init(GraphicDevice *pGD)
+{
+    struct s3c24x0_lcd * const lcd   = s3c24x0_get_base_lcd();
+    struct s3c2410_nand * const nand = s3c2410_get_base_nand();
+    /* FIXME: select LCM type by env variable */
+
+    /* Configuration for GTA01 LCM on QT2410 */
+    lcd->LCDCON1 = 0x00000378; /* CLKVAL=4, BPPMODE=16bpp, TFT, ENVID=0 */
+    lcd->LCDCON2 = (VBPD_240320<<24)|(LINEVAL_TFT_240320<<14)|(VFPD_240320<<6)|(VSPW_240320);
+    lcd->LCDCON3 = (HBPD_240320<<19)|(HOZVAL_TFT_240320<<8)|(HFPD_240320);
+
+    if ( (nand->NFCONF) & 0x08 )    {
+    lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320_TD);
+    }
+    else    {
+      lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320_NEC);
+    }
+
+    lcd->LCDCON5 = 0x00000f09;
+    lcd->LPCSEL  = 0x00000000;
+}
+#endif /*Console for LCD, add by guowenxue */
+
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+#if 0
+#if defined(CONFIG_CMD_NAND)
+extern ulong nand_probe(ulong physadr);
+
+static inline void NF_Reset(void)
+{
+	int i;
+
+	NF_SetCE(NFCE_LOW);
+	NF_Cmd(0xFF);		/* reset command */
+	for(i = 0; i < 10; i++);	/* tWB = 100ns. */
+	NF_WaitRB();		/* wait 200~500us; */
+	NF_SetCE(NFCE_HIGH);
+}
+
+static inline void NF_Init(void)
+{
+#if 1
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+#else
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+#endif
+
+	NF_Conf((1<<15)|(0<<14)|(0<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0));
+	/*nand->NFCONF = (1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0); */
+	/* 1  1    1     1,   1      xxx,  r xxx,   r xxx */
+	/* En 512B 4step ECCR nFCE=H tACLS   tWRPH0   tWRPH1 */
+
+	NF_Reset();
+}
+
+void nand_init(void)
+{
+	struct s3c2410_nand * const nand = s3c2410_get_base_nand();
+
+	NF_Init();
+#ifdef DEBUG
+	printf("NAND flash probing at 0x%.8lX\n", (ulong)nand);
+#endif
+	printf ("%4lu MB\n", nand_probe((ulong)nand) >> 20);
+}
+#endif
+#endif /*Comment by guowenxue*/
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_CS8900
+	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
+#endif
+#ifdef CONFIG_DRIVER_DM9000 /*Add by guowenxue*/
+    rc = dm9000_initialize(bis);
+#endif
+	return rc;
+}
+#endif
diff -Nuar u-boot-2010.09/board/kkernel/fl2440/flash.c u-boot-2010.09-fl2440/board/kkernel/fl2440/flash.c
--- u-boot-2010.09/board/kkernel/fl2440/flash.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/fl2440/flash.c	2013-04-25 17:06:35.285436660 +0800
@@ -0,0 +1,679 @@
+/*
+ * (C) Copyright 2003
+ * Martin Winistoerfer, martinwinistoerfer@gmx.ch.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * File:		flash.c, This file copy from board/cmi/flash.c 
+ *           and modify by guowenxue <guowenxue@gmail.com>
+ *
+ * Discription:		This Driver is for 28F320J3A, 28F640J3A and
+ *			28F128J3A Intel flashs working in 16 Bit mode.
+ *			Add JS28f320J3D75 4MB Norflash support by guowenxue
+ *			They are single bank flashs.
+ *
+ *			Most of this code is taken from existing u-boot
+ *			source code.
+ */
+
+
+#include <common.h>
+#include <mpc5xx.h>
+
+#if defined(CONFIG_ENV_IS_IN_FLASH)
+# ifndef  CONFIG_ENV_ADDR
+#  define CONFIG_ENV_ADDR	(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+# endif
+# ifndef  CONFIG_ENV_SIZE
+#  define CONFIG_ENV_SIZE	CONFIG_ENV_SECT_SIZE
+# endif
+# ifndef  CONFIG_ENV_SECT_SIZE
+#  define CONFIG_ENV_SECT_SIZE  CONFIG_ENV_SIZE
+# endif
+#endif
+
+#define	FLASH_ID_MASK			0xFFFF
+#define FLASH_BLOCK_SIZE		0x00020000  /* Modify by guowenxue */ 
+#define FLASH_CMD_READ_ID		0x0090
+#define FLASH_CMD_RESET			0x00ff
+#define FLASH_CMD_BLOCK_ERASE		0x0020
+#define FLASH_CMD_ERASE_CONFIRM		0x00D0
+#define FLASH_CMD_CLEAR_STATUS		0x0050
+#define FLASH_CMD_SUSPEND_ERASE		0x00B0
+#define FLASH_CMD_WRITE			0x0040
+#define FLASH_CMD_PROTECT		0x0060
+#define FLASH_CMD_PROTECT_SET		0x0001
+#define FLASH_CMD_PROTECT_CLEAR		0x00D0
+#define FLASH_STATUS_DONE		0x0080
+
+flash_info_t	flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+/*
+ * Local function prototypes
+ */
+static ulong	flash_get_size		(vu_short *addr, flash_info_t *info);
+//static int	write_short		(flash_info_t *info, ulong dest, ushort data);
+static int write_word (flash_info_t *info, ulong dest, ushort data);
+
+static void	flash_get_offsets	(ulong base, flash_info_t *info);
+
+/*
+ * Initialize flash
+ */
+
+unsigned long flash_init (void)
+{
+	unsigned long size_b0;
+	int i;
+
+	/* Init: no FLASHes known */
+	for (i=0; i<CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	/* Static FLASH Bank configuration here - FIXME XXX */
+#if 1
+	debug ("\n## Get flash bank 1 size @ 0x%08x\n",FLASH_BASE0_PRELIM);
+#endif
+	size_b0 = flash_get_size((vu_short *)FLASH_BASE0_PRELIM, &flash_info[0]);
+
+	if (flash_info[0].flash_id == FLASH_UNKNOWN) {
+		printf ("## Unknown FLASH on Bank 0: "
+			"ID 0x%lx, Size = 0x%08lx = %ld MB\n",
+			flash_info[0].flash_id,
+			size_b0, size_b0<<20);
+	}
+
+	flash_get_offsets (FLASH_BASE0_PRELIM, &flash_info[0]);
+
+	flash_info[0].size = size_b0;
+
+#if CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CONFIG_SYS_MONITOR_BASE,
+		      CONFIG_SYS_MONITOR_BASE+monitor_flash_len-1,
+		      &flash_info[0]);
+#endif
+
+#ifdef	CONFIG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CONFIG_ENV_ADDR,
+		      CONFIG_ENV_ADDR+CONFIG_ENV_SECT_SIZE-1,
+		      &flash_info[0]);
+#endif
+
+	return size_b0;
+}
+
+/*
+ * Compute start adress of each sector (block)
+ */
+
+static void flash_get_offsets (ulong base, flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+	    for (i = 0; i < info->sector_count; i++) {
+		info->start[i] = base + i * FLASH_BLOCK_SIZE;
+	    }
+	    return;
+
+	default:
+	    printf ("Don't know sector offsets for flash type 0x%lx\n",
+		info->flash_id);
+	    return;
+	}
+}
+
+/*
+ * Print flash information
+ */
+void flash_print_info  (flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("AMD ");		break;
+	case FLASH_MAN_FUJ:	printf ("Fujitsu ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+	case FLASH_MAN_INTEL:	printf ("Intel ");		break;
+	case FLASH_MAN_MT:	printf ("MT ");			break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F320J3A:	printf ("28F320J3A (32Mbit) 16-Bit\n");
+				break;
+	case FLASH_28F640J3A:	printf ("28F640J3A (64Mbit) 16-Bit\n");
+				break;
+	case FLASH_28F128J3A:	printf ("28F128J3A (128Mbit) 16-Bit\n");
+				break;
+	default:		printf ("Unknown Chip Type\n");
+				break;
+	}
+
+	if (info->size >= (1 << 20)) {
+		i = 20;
+	} else {
+		i = 10;
+	}
+	printf ("  Size: %ld %cB in %d Sectors\n",
+		info->size >> i,
+		(i == 20) ? 'M' : 'k',
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i=0; i<info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     "
+		);
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * Get size of flash in bytes.
+ * The following code cannot be run from FLASH!
+ */
+
+static ulong flash_get_size (vu_short *addr, flash_info_t *info)
+{
+	vu_short value;
+
+	/* Read Manufacturer ID */
+	addr[0] = FLASH_CMD_READ_ID;
+	value = addr[0];
+
+	switch (value) {
+	case (AMD_MANUFACT & FLASH_ID_MASK):
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+	case (FUJ_MANUFACT & FLASH_ID_MASK):
+		info->flash_id = FLASH_MAN_FUJ;
+		break;
+	case (SST_MANUFACT & FLASH_ID_MASK):
+		info->flash_id = FLASH_MAN_SST;
+		break;
+	case (STM_MANUFACT & FLASH_ID_MASK):
+		info->flash_id = FLASH_MAN_STM;
+		break;
+	case (INTEL_MANUFACT & FLASH_ID_MASK):
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		addr[0] = FLASH_CMD_RESET;	/* restore read mode */
+		return (0);			/* no or unknown flash	*/
+	}
+
+	value = addr[1];			/* device ID		*/
+
+	switch (value) {
+	case (INTEL_ID_28F320J3A  & FLASH_ID_MASK):
+		info->flash_id += FLASH_28F320J3A;
+		info->sector_count = 32;
+		info->size = 0x00400000;
+		break;				/* =>  32 MBit		*/
+
+	case (INTEL_ID_28F640J3A & FLASH_ID_MASK):
+		info->flash_id += FLASH_28F640J3A;
+		info->sector_count = 64;
+		info->size = 0x00800000;
+		break;				/* => 64 MBit		*/
+
+	case (INTEL_ID_28F128J3A & FLASH_ID_MASK):
+		info->flash_id += FLASH_28F128J3A;
+		info->sector_count = 128;
+		info->size = 0x01000000;
+		break;				/* => 128 MBit		*/
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		addr[0] = FLASH_CMD_RESET;	/* restore read mode */
+		return (0);			/* => no or unknown flash */
+
+	}
+
+	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+			info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
+		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+	}
+
+	addr[0] = FLASH_CMD_RESET;		/* restore read mode */
+
+	return (info->size);
+}
+
+
+/*
+ * Erase unprotected sectors
+ */
+
+int flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong start, now, last;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) != FLASH_MAN_INTEL) {
+		printf ("Can erase only Intel flash types - aborted\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	start = get_timer (0);
+	last  = start;
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *)(info->start[sect]);
+			unsigned long status;
+
+			/* Disable interrupts which might cause a timeout here */
+			flag = disable_interrupts();
+
+#ifdef DEBUG
+			printf("Erase sector %d at start addr 0x%08X", sect, (unsigned int)info->start[sect]);
+#endif
+
+			*addr = FLASH_CMD_CLEAR_STATUS;
+			*addr = FLASH_CMD_BLOCK_ERASE;
+			*addr = FLASH_CMD_ERASE_CONFIRM;
+
+			/* re-enable interrupts if necessary */
+			if (flag)
+				enable_interrupts();
+
+			/* wait at least 80us - let's wait 1 ms */
+			udelay (1000);
+
+			while (((status = *addr) & FLASH_STATUS_DONE) != FLASH_STATUS_DONE) {
+				if ((now=get_timer(start)) > CONFIG_SYS_FLASH_ERASE_TOUT) {
+					printf("Flash erase timeout at address %lx\n", info->start[sect]);
+					*addr = FLASH_CMD_SUSPEND_ERASE;
+					*addr = FLASH_CMD_RESET;
+					return 1;
+				}
+
+				/* show that we're waiting */
+				if ((now - last) > 1000) {	/* every second */
+					putc ('.');
+					last = now;
+				}
+			}
+			*addr = FLASH_CMD_RESET;
+		}
+	}
+	printf (" done\n");
+	return 0;
+}
+
+/* Add by guowenxue  */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt) 
+{ 
+    ulong cp, wp; 
+    ushort data; 
+    int l; 
+    int i, rc;
+    wp = (addr & ~1);        /*  get lower word aligned address */
+
+   /*  handle unaligned start bytes */ 
+    if ((l = addr - wp) != 0) 
+    { 
+        data = 0; 
+        for (i=0, cp=wp; i<l; ++i, ++cp) 
+        { 
+            data = (data >> 8) | (*(uchar *)cp << 8); 
+        } 
+        
+        for (; i<2 && cnt>0; ++i) 
+        { 
+            data = (data >> 8) | (*src++ << 8); 
+            --cnt; 
+            ++cp; 
+        } 
+        
+        for (; cnt==0 && i<2; ++i, ++cp) 
+        { 
+            data = (data >> 8) | (*(uchar *)cp << 8); 
+        }
+
+        if ((rc = write_word(info, wp, data)) != 0) 
+        { 
+            return (rc); 
+        } 
+        wp += 2; 
+    }
+
+   /*  handle word aligned part */ 
+
+    while (cnt >= 2) 
+    { 
+        data = *((vu_short*)src); 
+        if ((rc = write_word(info, wp, data)) != 0) 
+        { 
+            return (rc); 
+        } 
+        src += 2; 
+        wp  += 2; 
+        cnt -= 2; 
+    }
+    
+    if (cnt == 0) 
+    { 
+        return ERR_OK; 
+    }
+
+    /*  handle unaligned tail bytes   */ 
+    data = 0; 
+    for (i=0, cp=wp; i<2 && cnt>0; ++i, ++cp) 
+    { 
+        data = (data >> 8) | (*src++ << 8); 
+        --cnt; 
+    } 
+    
+    for (; i<2; ++i, ++cp) 
+    { 
+        data = (data >> 8) | (*(uchar *)cp << 8); 
+    }
+
+    return write_word(info, wp, data); 
+}
+
+
+/***************************************************************************************************** 
+ * Copy memory to flash. 
+ */
+static int write_word (flash_info_t *info, ulong dest, ushort data) 
+{ 
+   vu_short *addr = (vu_short *)dest, val; 
+   int rc = ERR_OK; 
+   int flag;
+   /*  Check if Flash is (sufficiently) erased , fix by kavin*/ 
+   if ((*addr & data) != data) 
+      return ERR_NOT_ERASED;
+   /*  
+    * Disable interrupts which might cause a timeout 
+    * here. Remember that our exception vectors are 
+    * at address 0 in the flash, and we don't want a 
+    * (ticker) exception to happen while the flash 
+    * chip is in programming mode. 
+    */ 
+   flag = disable_interrupts();
+
+   /*  clear status register command */ 
+   *addr = 0x50;
+
+   /*  program set-up command */ 
+   *addr = 0x40;
+
+   /*  latch address/data */ 
+   *addr = data;
+
+   /*  arm simple, non interrupt dependent timer */ 
+   reset_timer_masked();
+
+   /*  wait while polling the status register */ 
+   while(((val = *addr) & 0x80) != 0x80) 
+   { 
+      if (get_timer_masked() > CONFIG_SYS_FLASH_WRITE_TOUT) 
+      { 
+          rc = ERR_TIMOUT; 
+          /*  suspend program command */ 
+          *addr = 0xB0; 
+          goto outahere; 
+      } 
+   }
+
+   if(val & 0x1A) 
+   {        /*  check for error */ 
+       
+       printf("/nFlash write error %02x at address %08lx/n", (int)val, (unsigned long)dest); 
+       
+       if(val & (1<<3)) 
+       { 
+           printf("Voltage range error./n"); 
+           rc = ERR_PROG_ERROR; 
+           goto outahere; 
+       } 
+
+       if(val & (1<<1)) 
+       { 
+           printf("Device protect error./n"); 
+           rc = ERR_PROTECTED; 
+           goto outahere; 
+       } 
+
+       if(val & (1<<4)) 
+       { 
+           printf("Programming error./n"); 
+           rc = ERR_PROG_ERROR; 
+           goto outahere; 
+       } 
+
+       rc = ERR_PROG_ERROR; 
+       goto outahere; 
+   }
+
+outahere: 
+   /*  read array command */ 
+   *addr = 0xFF;
+   if (flag) 
+      enable_interrupts();
+   return rc; 
+}
+/* Add by guowenxue end  */
+
+#if 0 /* Comment by guowenxue */
+/*
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int i, rc;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start byte
+	 */
+
+	if (addr - wp) {
+		data = 0;
+		data = (data << 8) | *src++;
+		--cnt;
+		if ((rc = write_short(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+
+	while (cnt >= 2) {
+		data = 0;
+		for (i=0; i<2; ++i) {
+			data = (data << 8) | *src++;
+		}
+
+		if ((rc = write_short(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp  += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+
+	data = 0;
+	for (i=0, cp=wp; i<2 && cnt>0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i<2; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *)cp);
+	}
+
+	return (write_short(info, wp, data));
+
+}
+
+/*
+ * Write 16 bit (short) to flash
+ */
+
+static int write_short (flash_info_t *info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short*)(info->start[0]);
+	ulong start;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*((vu_short *)dest) & data) != data) {
+		return (2);
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	if (!(info->flash_id & FLASH_VENDMASK)) {
+		return 4;
+	}
+	*addr = FLASH_CMD_ERASE_CONFIRM;
+	*addr = FLASH_CMD_WRITE;
+
+	*((vu_short *)dest) = data;
+
+	/* re-enable interrupts if necessary */
+	if (flag) {
+		enable_interrupts();
+	}
+
+	/* data polling for D7 */
+	start = get_timer (0);
+
+	/* wait for error or finish */
+	while(!(addr[0] & FLASH_STATUS_DONE)){
+		if (get_timer(start) > CONFIG_SYS_FLASH_WRITE_TOUT) {
+			addr[0] = FLASH_CMD_RESET;
+			return (1);
+		}
+	}
+
+	*addr = FLASH_CMD_RESET;
+	return (0);
+}
+#endif
+
+/*
+ * Protects a flash sector
+ */
+
+int flash_real_protect(flash_info_t *info, long sector, int prot)
+{
+	vu_short *addr = (vu_short*)(info->start[sector]);
+	ulong start;
+
+	*addr = FLASH_CMD_CLEAR_STATUS;
+	*addr = FLASH_CMD_PROTECT;
+
+	if(prot) {
+		*addr = FLASH_CMD_PROTECT_SET;
+	} else {
+		*addr = FLASH_CMD_PROTECT_CLEAR;
+	}
+
+	/* wait for error or finish */
+	start = get_timer (0);
+	while(!(addr[0] & FLASH_STATUS_DONE)){
+		if (get_timer(start) > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			printf("Flash protect timeout at address %lx\n",  info->start[sector]);
+			addr[0] = FLASH_CMD_RESET;
+			return (1);
+		}
+	}
+	/* Set software protect flag */
+	info->protect[sector] = prot;
+	*addr = FLASH_CMD_RESET;
+	return (0);
+}
diff -Nuar u-boot-2010.09/board/kkernel/fl2440/lowlevel_init.S u-boot-2010.09-fl2440/board/kkernel/fl2440/lowlevel_init.S
--- u-boot-2010.09/board/kkernel/fl2440/lowlevel_init.S	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/fl2440/lowlevel_init.S	2013-04-25 17:06:35.285436660 +0800
@@ -0,0 +1,273 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * Modified for the friendly-arm SBC-2410X by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/*
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW16)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+#define B0_Tacs			0x0
+#define B0_Tcos			0x0
+#define B0_Tacc			0x7
+#define B0_Tcoh			0x0
+#define B0_Tah			0x0
+#define B0_Tacp			0x0
+#define B0_PMC			0x0
+
+#define B1_Tacs			0x0
+#define B1_Tcos			0x0
+#define B1_Tacc			0x7
+#define B1_Tcoh			0x0
+#define B1_Tah			0x0
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0xc
+#define B3_Tcos			0x7
+#define B3_Tacc			0xf
+#define B3_Tcoh			0x1
+#define B3_Tah			0x0
+#define B3_Tacp			0x0
+#define B3_PMC			0x0
+
+#define B4_Tacs			0x0
+#define B4_Tcos			0x0
+#define B4_Tacc			0x7
+#define B4_Tcoh			0x0
+#define B4_Tah			0x0
+#define B4_Tacp			0x0
+#define B4_PMC			0x0
+
+#define B5_Tacs			0xc
+#define B5_Tcos			0x7
+#define B5_Tacc			0xf
+#define B5_Tcoh			0x1
+#define B5_Tah			0x0
+#define B5_Tacp			0x0
+#define B5_PMC			0x0
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+
+#if defined(CONFIG_S3C2440)
+#define Trp         0x2 /* 4clk */
+#define REFCNT          1012
+#else
+#define Trp         0x0 /* 2clk */
+#define REFCNT			0x0459
+#endif
+/**************************************/
+
+#define S3C24X0_INTERRUPT_BASE      0x4A000000
+#define S3C24X0_CLOCK_POWER_BASE    0x4C000000
+#define S3C2410_NAND_BASE           0x4E000000
+#define S3C24X0_WATCHDOG_BASE       0x53000000
+#define S3C24X0_GPIO_BASE           0x56000000
+#define GPBCON                      0x56000010
+#define GPBDAT                      0x56000014
+#define GPBUP                       0x56000018
+
+#define INTMSK_OFFSET               0x08
+#define INTSUBMSK_OFFSET            0x1c
+#define MPLLCON_OFFSET              0x04
+#define CLKDIVN_OFFSET              0x14
+#define NFCONF_OFFSET               0x00
+#define NFCONT_OFFSET               0x04
+#define NFCMD_OFFSET                0x08
+#define NFSTAT_OFFSET               0x20
+
+#define MDIV_405                    0x7f << 12
+#define PSDIV_405                   0x21        
+#define MDIV_200                    0xa1 << 12 
+#define PSDIV_200                   0x31        
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+    /****** Disable Watchdog ******/
+    ldr r0, =S3C24X0_WATCHDOG_BASE
+    mov r1, #0
+    str r1, [r0]
+
+    /****** Disable interrupt by mask all IRQ mask ******/
+    ldr r0, =S3C24X0_INTERRUPT_BASE
+    mvn r1, #0x0
+    str r1, [r0, #INTMSK_OFFSET]
+    str r1, [r0, #INTSUBMSK_OFFSET]
+
+    /****** Initialize System Clock, FCLK:HCLK:PCLK = 1:4:8,default FCLK is 120MHz ******/
+    ldr r0, =S3C24X0_CLOCK_POWER_BASE
+    mov r1, #5
+    str r1, [r0, #CLKDIVN_OFFSET]
+    
+    mrc p15, 0, r1, c1, c0, 0
+    orr r1, r1, #0xc0000000
+    mcr p15, 0, r1, c1, c0, 0
+
+    mov r2, #MDIV_405
+    add r2, r2, #PSDIV_405
+    str r2, [r0, #MPLLCON_OFFSET]
+
+    /****** Initialize LED GPIO port ******/
+#if defined(CONFIG_FL2440_LED) 
+    /*Set GPIO5, GPIO6, GPIO8, GPIO10 as GPIO OUTPUT mode*/
+    ldr r0, =GPBCON
+    ldr r1, [r0]
+    bic r1, r1, #0x3c00      /*Set GPBCON for GPIO5,GPIO6 as 0x00 */
+    orr r1, r1, #0x1400      /*Set GPBCON for GPIO5,GPIO6 as GPIOOUT, 0x01*/
+    bic r1, r1, #0x00330000  /*Set GPBCON for GPIO8,GPIO10 as 0x00*/
+    orr r1, r1, #0x00110000  /*Set GPBCON for GPIO8,GPIO10 as GPIOOUT, 0x01*/
+    str r1, [r0]
+
+    /*Set internal pullup resister*/ 
+    ldr r0, =GPBUP 
+    ldr r1, [r0] 
+    orr r1, r1, #0x0560     /*Set bit 5,6,8,10, disable pullup resister*/ 
+    @bic r1, r1, #0x0560    /*Clear bit 5,6,8,10, enable pullup resister*/ 
+    str r1, [r0]
+
+    ldr     r2, =GPBDAT
+    ldr     r3, [r2]
+    orr     r3, r3, #0x0560     /*Set bit 5,6,8,10 as high level, Turn Off LED*/
+    str     r3, [r2]
+#endif
+
+   /***** Initialize Nandflash controller ******/
+    mov r1, #S3C2410_NAND_BASE
+    ldr r2, =( (7<<12)|(7<<8)|(7<<4)|(0<<0) )
+    str r2, [r1, #NFCONF_OFFSET]
+
+    ldr r2, =( (1<<4)|(0<<1)|(1<<0) )   @ Active low CE Control
+    str r2, [r1, #NFCONT_OFFSET]
+    
+    ldr r2, =(0x6)                      @ RnB Clear
+    str r2, [r1, #NFSTAT_OFFSET]
+
+    mov r2, #0xff                       @ Reset Nandflash
+    strb    r2, [r1, #NFCMD_OFFSET]
+    
+    mov r3, #0       @ Delay for a while
+delay:
+    add r3, r3, #0x1
+    cmp r3, #0xa
+    blt delay   
+
+wait:
+    ldr r2, [r1, #NFSTAT_OFFSET]  @ wait ready
+    tst r2, #0x4
+    beq wait
+
+mem_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+    ldr r1, =mem_init
+	sub	r0, r0, r1
+    adr r3, mem_init       /* r3 <- current position of code   */
+    add r0, r0, r3
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+    ldr r1, =GPBDAT
+    ldr r2, [r1]
+    bic r2, r2, #(1<<5)  
+    str r2, [r1]
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb2
+    .word 0x30
+    .word 0x30
diff -Nuar u-boot-2010.09/board/kkernel/fl2440/Makefile u-boot-2010.09-fl2440/board/kkernel/fl2440/Makefile
--- u-boot-2010.09/board/kkernel/fl2440/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/fl2440/Makefile	2013-04-25 17:06:35.285436660 +0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= fl2440.o nand_read.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Nuar u-boot-2010.09/board/kkernel/fl2440/nand_read.c u-boot-2010.09-fl2440/board/kkernel/fl2440/nand_read.c
--- u-boot-2010.09/board/kkernel/fl2440/nand_read.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/fl2440/nand_read.c	2013-04-25 17:06:35.286475252 +0800
@@ -0,0 +1,235 @@
+/*
+ * nand_read.c: Simple NAND read functions for booting from NAND
+ *
+ * This is used by cpu/arm920/start.S assembler code,
+ * and the board-specific linker script must make sure this
+ * file is linked within the first 4kB of NAND flash.
+ *
+ * Taken from GPLv2 licensed vivi bootloader,
+ * Copyright (C) 2002 MIZI Research, Inc.
+ *
+ * Author: Hwang, Chideok <hwang@mizi.com>
+ * Date  : $Date: 2004/02/04 10:37:37 $
+ *
+ * u-boot integration and bad-block skipping (C) 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ */
+
+#include <common.h>
+#include <linux/mtd/nand.h>
+
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGw(x)	(*(volatile unsigned short *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+#define NF_BASE		0x4e000000
+#if defined(CONFIG_S3C2410)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCMD		__REGb(NF_BASE + 0x4)
+#define NFADDR		__REGb(NF_BASE + 0x8)
+#define NFDATA		__REGb(NF_BASE + 0xc)
+#define NFSTAT		__REGb(NF_BASE + 0x10)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONF &= ~0x800)
+#define nand_deselect()	(NFCONF |= 0x800)
+#define nand_clear_RnB()	do {} while (0)
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCONT		__REGi(NF_BASE + 0x4)
+#define NFCMD		__REGb(NF_BASE + 0x8)
+#define NFADDR		__REGb(NF_BASE + 0xc)
+#define NFDATA		__REGb(NF_BASE + 0x10)
+#define NFDATA16	__REGw(NF_BASE + 0x10)
+#define NFSTAT		__REGb(NF_BASE + 0x20)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONT &= ~(1 << 1))
+#define nand_deselect()	(NFCONT |= (1 << 1))
+#define nand_clear_RnB()	(NFSTAT |= (1 << 2))
+#endif
+
+static inline void nand_wait(void)
+{
+	int i;
+
+	while (!(NFSTAT & NFSTAT_BUSY))
+		for (i=0; i<10; i++);
+}
+
+struct boot_nand_t {
+	int page_size;
+	int block_size;
+	int bad_block_offset;
+//	unsigned long size;
+};
+
+#if 0
+#if defined(CONFIG_S3C2410) || defined(CONFIG_MINI2440)
+/* configuration for 2410 with 512byte sized flash */
+#define NAND_PAGE_SIZE		512
+#define BAD_BLOCK_OFFSET	5
+#define NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		0x4000
+#else
+/* configuration for 2440 with 2048byte sized flash */
+#define NAND_5_ADDR_CYCLE
+#define NAND_PAGE_SIZE		2048
+#define BAD_BLOCK_OFFSET	NAND_PAGE_SIZE
+#define	NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		(NAND_PAGE_SIZE * 64)
+#endif
+
+/* compile time failure in case of an invalid configuration */
+#if defined(CONFIG_S3C2410) && (NAND_PAGE_SIZE != 512)
+#error "S3C2410 does not support nand page size != 512"
+#endif
+#endif
+
+static int is_bad_block(struct boot_nand_t * nand, unsigned long i)
+{
+	unsigned char data;
+	unsigned long page_num;
+
+	nand_clear_RnB();
+	if (nand->page_size == 512) {
+		NFCMD = NAND_CMD_READOOB; /* 0x50 */
+		NFADDR = nand->bad_block_offset & 0xf;
+		NFADDR = (i >> 9) & 0xff;
+		NFADDR = (i >> 17) & 0xff;
+		NFADDR = (i >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = i >> 11; /* addr / 2048 */
+		NFCMD = NAND_CMD_READ0;
+		NFADDR = nand->bad_block_offset & 0xff;
+		NFADDR = (nand->bad_block_offset >> 8) & 0xff;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+	data = (NFDATA & 0xff);
+	if (data != 0xff)
+		return 1;
+
+	return 0;
+}
+
+static int nand_read_page_ll(struct boot_nand_t * nand, unsigned char *buf, unsigned long addr)
+{
+	unsigned short *ptr16 = (unsigned short *)buf;
+	unsigned int i, page_num;
+
+	nand_clear_RnB();
+
+	NFCMD = NAND_CMD_READ0;
+
+	if (nand->page_size == 512) {
+		/* Write Address */
+		NFADDR = addr & 0xff;
+		NFADDR = (addr >> 9) & 0xff;
+		NFADDR = (addr >> 17) & 0xff;
+		NFADDR = (addr >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = addr >> 11; /* addr / 2048 */
+		/* Write Address */
+		NFADDR = 0;
+		NFADDR = 0;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+
+#if defined(CONFIG_S3C2410)
+	for (i = 0; i < nand->page_size; i++) {
+		*buf = (NFDATA & 0xff);
+		buf++;
+	}
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	for (i = 0; i < (nand->page_size>>1); i++) {
+		*ptr16 = NFDATA16;
+		ptr16++;
+	}
+#endif
+
+	return nand->page_size;
+}
+
+static unsigned short nand_read_id()
+{
+	unsigned short res = 0;
+	NFCMD = NAND_CMD_READID;
+	NFADDR = 0;
+	res = NFDATA;
+	res = (res << 8) | NFDATA;
+	return res;
+}
+
+extern unsigned int dynpart_size[];
+
+/* low level nand read function */
+int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+	int i, j;
+	unsigned short nand_id;
+	struct boot_nand_t nand;
+
+	/* chip Enable */
+	nand_select();
+	nand_clear_RnB();
+	
+	for (i = 0; i < 10; i++)
+		;
+	nand_id = nand_read_id();
+	if (0) { /* dirty little hack to detect if nand id is misread */
+		unsigned short * nid = (unsigned short *)0x31fffff0;
+		*nid = nand_id;
+	}	
+
+       if (nand_id == 0xec76 ||		/* Samsung K91208 on SD2410 board */
+           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
+		nand.page_size = 512;
+		nand.block_size = 16 * 1024;
+		nand.bad_block_offset = 5;
+	//	nand.size = 0x4000000;
+	} else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
+           nand_id == 0xadda || /*  Hynix HY27UF082G2B on FL2440 board */
+		   nand_id == 0xecda ||	/* Samsung K9F2G08U0B on FL2440 board */
+		   nand_id == 0xecd3 )	{ /* Samsung K9K8G08 */
+		nand.page_size = 2048;
+		nand.block_size = 128 * 1024;
+		nand.bad_block_offset = nand.page_size;
+	//	nand.size = 0x8000000;
+	} else {
+		return -1; // hang
+	}
+	if ((start_addr & (nand.block_size-1)) || (size & ((nand.block_size-1))))
+		return -1;	/* invalid alignment */
+
+	for (i=start_addr; i < (start_addr + size);) {
+#ifdef CONFIG_S3C2410_NAND_SKIP_BAD
+		if (i & (nand.block_size-1)== 0) {
+			if (is_bad_block(&nand, i) ||
+			    is_bad_block(&nand, i + nand.page_size)) {
+				/* Bad block */
+				i += nand.block_size;
+				size += nand.block_size;
+				continue;
+			}
+		}
+#endif
+		j = nand_read_page_ll(&nand, buf, i);
+		i += j;
+		buf += j;
+	}
+
+	/* chip Disable */
+	nand_deselect();
+
+	return 0;
+}
diff -Nuar u-boot-2010.09/board/kkernel/sd2410/config.mk u-boot-2010.09-fl2440/board/kkernel/sd2410/config.mk
--- u-boot-2010.09/board/kkernel/sd2410/config.mk	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/sd2410/config.mk	2013-04-25 17:06:35.286475252 +0800
@@ -0,0 +1,23 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+
+TEXT_BASE = 0x33F80000
diff -Nuar u-boot-2010.09/board/kkernel/sd2410/flash.c u-boot-2010.09-fl2440/board/kkernel/sd2410/flash.c
--- u-boot-2010.09/board/kkernel/sd2410/flash.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/sd2410/flash.c	2013-04-25 17:06:35.286475252 +0800
@@ -0,0 +1,431 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CONFIG_SYS_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_SYS_FLASH_BASE,
+		       CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CONFIG_SYS_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff -Nuar u-boot-2010.09/board/kkernel/sd2410/lowlevel_init.S u-boot-2010.09-fl2440/board/kkernel/sd2410/lowlevel_init.S
--- u-boot-2010.09/board/kkernel/sd2410/lowlevel_init.S	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/sd2410/lowlevel_init.S	2013-04-25 17:06:35.287440402 +0800
@@ -0,0 +1,243 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * Modified for the friendly-arm SBC-2410X by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/*
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW16)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+#define B0_Tacs			0x0
+#define B0_Tcos			0x0
+#define B0_Tacc			0x7
+#define B0_Tcoh			0x0
+#define B0_Tah			0x0
+#define B0_Tacp			0x0
+#define B0_PMC			0x0
+
+#define B1_Tacs			0x0
+#define B1_Tcos			0x0
+#define B1_Tacc			0x7
+#define B1_Tcoh			0x0
+#define B1_Tah			0x0
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0xc
+#define B3_Tcos			0x7
+#define B3_Tacc			0xf
+#define B3_Tcoh			0x1
+#define B3_Tah			0x0
+#define B3_Tacp			0x0
+#define B3_PMC			0x0
+
+#define B4_Tacs			0x0
+#define B4_Tcos			0x0
+#define B4_Tacc			0x7
+#define B4_Tcoh			0x0
+#define B4_Tah			0x0
+#define B4_Tacp			0x0
+#define B4_PMC			0x0
+
+#define B5_Tacs			0xc
+#define B5_Tcos			0x7
+#define B5_Tacc			0xf
+#define B5_Tcoh			0x1
+#define B5_Tah			0x0
+#define B5_Tacp			0x0
+#define B5_PMC			0x0
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+
+#if defined(CONFIG_S3C2440)
+#define Trp         0x2 /* 4clk */
+#define REFCNT          1012
+#else
+#define Trp         0x0 /* 2clk */
+#define REFCNT			0x0459
+#endif
+/**************************************/
+
+#define S3C24X0_INTERRUPT_BASE      0x4A000000
+#define S3C24X0_CLOCK_POWER_BASE    0x4C000000
+#define S3C2410_NAND_BASE           0x4E000000
+#define S3C24X0_WATCHDOG_BASE       0x53000000
+
+#define INTMSK_OFFSET               0x08
+#define INTSUBMSK_OFFSET            0x1c
+#define MPLLCON_OFFSET              0x04
+#define CLKDIVN_OFFSET              0x14
+#define NFCONF_OFFSET               0x00
+#define NFCMD_OFFSET                0x04
+#define NFSTAT_OFFSET               0x10
+
+#define MDIV_200                    0xa1 << 12
+#define PSDIV_200                   0x31
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+
+    /* Disable Watchdog */
+    ldr r0, =S3C24X0_WATCHDOG_BASE
+    mov r1, #0
+    str r1, [r0]
+
+    /* mask all IRQs by setting all bits in the INTMR - default */
+    ldr r0, =S3C24X0_INTERRUPT_BASE
+    mvn r1, #0x0
+    str r1, [r0, #INTMSK_OFFSET]
+    str r1, [r0, #INTSUBMSK_OFFSET]
+
+    /* Initialize System Clock, FCLK:HCLK:PCLK = 1:4:8,default FCLK is 120MHz */
+    ldr r0, =S3C24X0_CLOCK_POWER_BASE
+    mov r1, #3
+    str r1, [r0, #CLKDIVN_OFFSET]
+
+    mrc p15, 0, r1, c1, c0, 0
+    orr r1, r1, #0xc0000000
+    mcr p15, 0, r1, c1, c0, 0
+
+    mov r2, #MDIV_200
+    add r2, r2, #PSDIV_200
+    str r2, [r0, #MPLLCON_OFFSET]
+
+   /***** Initialize Nandflash controller ******/
+    mov r1, #S3C2410_NAND_BASE
+    ldr r2, =0xf830                 @Initial value
+    str r2, [r1, #NFCONF_OFFSET]
+    ldr r2, [r1, #NFCONF_OFFSET]
+    bic r2, r2, #0x800              @enable chip
+    str r2, [r1, #NFCONF_OFFSET]
+
+    ldr r2, =(0x6)  @ RnB Clear
+    str r2, [r1, #NFSTAT_OFFSET]
+
+    mov r2, #0xff                   @reset Nandflash
+    strb    r2, [r1, #NFCMD_OFFSET]
+
+    /*Wait Nandflash reset OK*/
+    mov r3, #0 
+delay:
+    add r3, r3, #0x1
+    cmp r3, #0xa
+    blt delay
+
+wait:
+    ldr r2, [r1, #NFSTAT_OFFSET]    @wait ready
+    tst r2, #0x1
+    beq wait
+
+    ldr r2, [r1, #NFCONF_OFFSET]
+    orr r2, r2, #0x800              @Disable chip
+    str r2, [r1, #NFCONF_OFFSET]    
+
+mem_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+    ldr r1, =mem_init
+	sub	r0, r0, r1
+    adr r3, mem_init       /* r3 <- current position of code   */
+    add     r0, r0, r3
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb2
+    .word 0x30
+    .word 0x30
diff -Nuar u-boot-2010.09/board/kkernel/sd2410/Makefile u-boot-2010.09-fl2440/board/kkernel/sd2410/Makefile
--- u-boot-2010.09/board/kkernel/sd2410/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/sd2410/Makefile	2013-04-25 17:06:35.287440402 +0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= sd2410.o nand_read.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Nuar u-boot-2010.09/board/kkernel/sd2410/nand_read.c u-boot-2010.09-fl2440/board/kkernel/sd2410/nand_read.c
--- u-boot-2010.09/board/kkernel/sd2410/nand_read.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/sd2410/nand_read.c	2013-04-25 17:06:35.287440402 +0800
@@ -0,0 +1,234 @@
+/*
+ * nand_read.c: Simple NAND read functions for booting from NAND
+ *
+ * This is used by cpu/arm920/start.S assembler code,
+ * and the board-specific linker script must make sure this
+ * file is linked within the first 4kB of NAND flash.
+ *
+ * Taken from GPLv2 licensed vivi bootloader,
+ * Copyright (C) 2002 MIZI Research, Inc.
+ *
+ * Author: Hwang, Chideok <hwang@mizi.com>
+ * Date  : $Date: 2004/02/04 10:37:37 $
+ *
+ * u-boot integration and bad-block skipping (C) 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ */
+
+#include <common.h>
+#include <linux/mtd/nand.h>
+
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGw(x)	(*(volatile unsigned short *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+#define NF_BASE		0x4e000000
+#if defined(CONFIG_S3C2410)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCMD		__REGb(NF_BASE + 0x4)
+#define NFADDR		__REGb(NF_BASE + 0x8)
+#define NFDATA		__REGb(NF_BASE + 0xc)
+#define NFSTAT		__REGb(NF_BASE + 0x10)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONF &= ~0x800)
+#define nand_deselect()	(NFCONF |= 0x800)
+#define nand_clear_RnB()	do {} while (0)
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCONT		__REGi(NF_BASE + 0x4)
+#define NFCMD		__REGb(NF_BASE + 0x8)
+#define NFADDR		__REGb(NF_BASE + 0xc)
+#define NFDATA		__REGb(NF_BASE + 0x10)
+#define NFDATA16	__REGw(NF_BASE + 0x10)
+#define NFSTAT		__REGb(NF_BASE + 0x20)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONT &= ~(1 << 1))
+#define nand_deselect()	(NFCONT |= (1 << 1))
+#define nand_clear_RnB()	(NFSTAT |= (1 << 2))
+#endif
+
+static inline void nand_wait(void)
+{
+	int i;
+
+	while (!(NFSTAT & NFSTAT_BUSY))
+		for (i=0; i<10; i++);
+}
+
+struct boot_nand_t {
+	int page_size;
+	int block_size;
+	int bad_block_offset;
+//	unsigned long size;
+};
+
+#if 0
+#if defined(CONFIG_S3C2410) || defined(CONFIG_MINI2440)
+/* configuration for 2410 with 512byte sized flash */
+#define NAND_PAGE_SIZE		512
+#define BAD_BLOCK_OFFSET	5
+#define NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		0x4000
+#else
+/* configuration for 2440 with 2048byte sized flash */
+#define NAND_5_ADDR_CYCLE
+#define NAND_PAGE_SIZE		2048
+#define BAD_BLOCK_OFFSET	NAND_PAGE_SIZE
+#define	NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		(NAND_PAGE_SIZE * 64)
+#endif
+
+/* compile time failure in case of an invalid configuration */
+#if defined(CONFIG_S3C2410) && (NAND_PAGE_SIZE != 512)
+#error "S3C2410 does not support nand page size != 512"
+#endif
+#endif
+
+static int is_bad_block(struct boot_nand_t * nand, unsigned long i)
+{
+	unsigned char data;
+	unsigned long page_num;
+
+	nand_clear_RnB();
+	if (nand->page_size == 512) {
+		NFCMD = NAND_CMD_READOOB; /* 0x50 */
+		NFADDR = nand->bad_block_offset & 0xf;
+		NFADDR = (i >> 9) & 0xff;
+		NFADDR = (i >> 17) & 0xff;
+		NFADDR = (i >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = i >> 11; /* addr / 2048 */
+		NFCMD = NAND_CMD_READ0;
+		NFADDR = nand->bad_block_offset & 0xff;
+		NFADDR = (nand->bad_block_offset >> 8) & 0xff;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+	data = (NFDATA & 0xff);
+	if (data != 0xff)
+		return 1;
+
+	return 0;
+}
+
+static int nand_read_page_ll(struct boot_nand_t * nand, unsigned char *buf, unsigned long addr)
+{
+	unsigned short *ptr16 = (unsigned short *)buf;
+	unsigned int i, page_num;
+
+	nand_clear_RnB();
+
+	NFCMD = NAND_CMD_READ0;
+
+	if (nand->page_size == 512) {
+		/* Write Address */
+		NFADDR = addr & 0xff;
+		NFADDR = (addr >> 9) & 0xff;
+		NFADDR = (addr >> 17) & 0xff;
+		NFADDR = (addr >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = addr >> 11; /* addr / 2048 */
+		/* Write Address */
+		NFADDR = 0;
+		NFADDR = 0;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+
+#if defined(CONFIG_S3C2410)
+	for (i = 0; i < nand->page_size; i++) {
+		*buf = (NFDATA & 0xff);
+		buf++;
+	}
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	for (i = 0; i < (nand->page_size>>1); i++) {
+		*ptr16 = NFDATA16;
+		ptr16++;
+	}
+#endif
+
+	return nand->page_size;
+}
+
+static unsigned short nand_read_id()
+{
+	unsigned short res = 0;
+	NFCMD = NAND_CMD_READID;
+	NFADDR = 0;
+	res = NFDATA;
+	res = (res << 8) | NFDATA;
+	return res;
+}
+
+extern unsigned int dynpart_size[];
+
+/* low level nand read function */
+int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+	int i, j;
+	unsigned short nand_id;
+	struct boot_nand_t nand;
+
+	/* chip Enable */
+	nand_select();
+	nand_clear_RnB();
+	
+	for (i = 0; i < 10; i++)
+		;
+	nand_id = nand_read_id();
+	if (0) { /* dirty little hack to detect if nand id is misread */
+		unsigned short * nid = (unsigned short *)0x31fffff0;
+		*nid = nand_id;
+	}	
+
+       if (nand_id == 0xec76 ||		/* Samsung K91208 on SD2410 board */
+           nand_id == 0xad76 ) {	/*Hynix HY27US08121A*/
+		nand.page_size = 512;
+		nand.block_size = 16 * 1024;
+		nand.bad_block_offset = 5;
+	//	nand.size = 0x4000000;
+	} else if (nand_id == 0xecf1 ||	/* Samsung K9F1G08U0B */
+		   nand_id == 0xecda ||	/* Samsung K9F2G08U0B on FL2440 board */
+		   nand_id == 0xecd3 )	{ /* Samsung K9K8G08 */
+		nand.page_size = 2048;
+		nand.block_size = 128 * 1024;
+		nand.bad_block_offset = nand.page_size;
+	//	nand.size = 0x8000000;
+	} else {
+		return -1; // hang
+	}
+	if ((start_addr & (nand.block_size-1)) || (size & ((nand.block_size-1))))
+		return -1;	/* invalid alignment */
+
+	for (i=start_addr; i < (start_addr + size);) {
+#ifdef CONFIG_S3C2410_NAND_SKIP_BAD
+		if (i & (nand.block_size-1)== 0) {
+			if (is_bad_block(&nand, i) ||
+			    is_bad_block(&nand, i + nand.page_size)) {
+				/* Bad block */
+				i += nand.block_size;
+				size += nand.block_size;
+				continue;
+			}
+		}
+#endif
+		j = nand_read_page_ll(&nand, buf, i);
+		i += j;
+		buf += j;
+	}
+
+	/* chip Disable */
+	nand_deselect();
+
+	return 0;
+}
diff -Nuar u-boot-2010.09/board/kkernel/sd2410/sd2410.c u-boot-2010.09-fl2440/board/kkernel/sd2410/sd2410.c
--- u-boot-2010.09/board/kkernel/sd2410/sd2410.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/board/kkernel/sd2410/sd2410.c	2013-04-25 17:06:35.287440402 +0800
@@ -0,0 +1,297 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <video_fb.h> /*Add by guowenxue*/
+
+#if defined(CONFIG_CMD_NAND)
+#include <linux/mtd/nand.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+
+#if defined(CONFIG_S3C2410)
+/* Fout = 202.8MHz */
+#define M_MDIV  0xA1
+#define M_PDIV  0x3
+#define M_SDIV  0x1
+#endif
+
+#if defined(CONFIG_S3C2440)
+/* Fout = 405MHz */
+#define M_MDIV 0x7f 
+#define M_PDIV 0x2
+#define M_SDIV 0x1
+#endif
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+
+#if defined(CONFIG_S3C2410)
+#define U_M_MDIV    0x48
+#define U_M_PDIV    0x3
+#endif
+
+#if defined(CONFIG_S3C2440)
+#define U_M_MDIV 0x38
+#define U_M_PDIV 0x2
+#endif
+
+#define U_M_SDIV	0x2
+#endif
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+			  "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	struct s3c24x0_clock_power * const clk_power =
+					s3c24x0_get_base_clock_power();
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+	gpio->GPACON = 0x007FFFFF;
+
+#if defined(CONFIG_FL2440)
+    gpio->GPBCON = 0x00295550;
+#else
+	gpio->GPBCON = 0x00044554;
+#endif
+
+	gpio->GPBUP = 0x000007FF;
+
+#if defined(CONFIG_FL2440)
+    gpio->GPCCON = 0xAAAAA6AA;
+    gpio->GPCDAT &= ~(1<<5);
+#else
+	gpio->GPCCON = 0xAAAAAAAA;
+#endif
+	gpio->GPCUP = 0xFFFFFFFF;
+	gpio->GPDCON = 0xAAAAAAAA;
+	gpio->GPDUP = 0xFFFFFFFF;
+
+	gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+	gpio->GPFCON = 0x000055AA;
+	gpio->GPFUP = 0x000000FF;
+	gpio->GPGCON = 0xFF95FF3A;
+	gpio->GPGUP = 0x0000FFFF;
+	gpio->GPHCON = 0x0016FAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	gpio->EXTINT0=0x22222222;
+	gpio->EXTINT1=0x22222222;
+	gpio->EXTINT2=0x22222222;
+
+#if defined(CONFIG_S3C2410)
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+#endif
+
+#if defined(CONFIG_S3C2440)
+    /* arch number of S3C2440-Board */
+    gd->bd->bi_arch_number = MACH_TYPE_MINI2440 ; /*Use MINI2440 board*/
+#endif
+
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+#if defined(CONFIG_FL2440_LED)
+    gpio->GPBDAT = 0x00000181;
+#endif
+
+	return 0;
+}
+
+#ifdef  CONFIG_FL2440_CONSOLE_LCD /*This part add by guowenxue*/ 
+#define MVAL        (0)
+#define MVAL_USED   (0)     //0=each frame   1=rate by MVAL
+#define INVVDEN     (1)     //0=normal       1=inverted
+#define BSWP        (0)     //Byte swap control
+#define HWSWP       (1)     //Half word swap control
+
+
+//TFT 240320
+#define LCD_XSIZE_TFT_240320    (240)   
+#define LCD_YSIZE_TFT_240320    (320)
+
+//TFT240320
+#define HOZVAL_TFT_240320   (LCD_XSIZE_TFT_240320-1)
+#define LINEVAL_TFT_240320  (LCD_YSIZE_TFT_240320-1)
+
+//Timing parameter for NEC3.5"
+#define VBPD_240320     (3)     
+#define VFPD_240320     (10)
+#define VSPW_240320     (1)
+
+#define HBPD_240320     (5)
+#define HFPD_240320     (2)
+#define HSPW_240320_NEC     (36)  //Adjust the horizontal displacement of the screen :tekkamanninja@
+163.com
+#define HSPW_240320_TD      (23)  //64MB nand mini2440 is 36 ,128MB is 23
+                      //+ ??~Z -->    - : <--
+#define CLKVAL_TFT_240320   (3)     
+//FCLK=101.25MHz,HCLK=50.625MHz,VCLK=6.33MHz
+
+void board_video_init(GraphicDevice *pGD)
+{
+    struct s3c24x0_lcd * const lcd   = s3c24x0_get_base_lcd();
+    struct s3c2410_nand * const nand = s3c2410_get_base_nand();
+    /* FIXME: select LCM type by env variable */
+
+    /* Configuration for GTA01 LCM on QT2410 */
+    lcd->LCDCON1 = 0x00000378; /* CLKVAL=4, BPPMODE=16bpp, TFT, ENVID=0 */
+    lcd->LCDCON2 = (VBPD_240320<<24)|(LINEVAL_TFT_240320<<14)|(VFPD_240320<<6)|(VSPW_240320);
+    lcd->LCDCON3 = (HBPD_240320<<19)|(HOZVAL_TFT_240320<<8)|(HFPD_240320);
+
+    if ( (nand->NFCONF) & 0x08 )    {
+    lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320_TD);
+    }
+    else    {
+      lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320_NEC);
+    }
+
+    lcd->LCDCON5 = 0x00000f09;
+    lcd->LPCSEL  = 0x00000000;
+}
+#endif /*Console for LCD, add by guowenxue */
+
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+#if 0
+#if defined(CONFIG_CMD_NAND)
+extern ulong nand_probe(ulong physadr);
+
+static inline void NF_Reset(void)
+{
+	int i;
+
+	NF_SetCE(NFCE_LOW);
+	NF_Cmd(0xFF);		/* reset command */
+	for(i = 0; i < 10; i++);	/* tWB = 100ns. */
+	NF_WaitRB();		/* wait 200~500us; */
+	NF_SetCE(NFCE_HIGH);
+}
+
+static inline void NF_Init(void)
+{
+#if 1
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+#else
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+#endif
+
+	NF_Conf((1<<15)|(0<<14)|(0<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0));
+	/*nand->NFCONF = (1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0); */
+	/* 1  1    1     1,   1      xxx,  r xxx,   r xxx */
+	/* En 512B 4step ECCR nFCE=H tACLS   tWRPH0   tWRPH1 */
+
+	NF_Reset();
+}
+
+void nand_init(void)
+{
+	struct s3c2410_nand * const nand = s3c2410_get_base_nand();
+
+	NF_Init();
+#ifdef DEBUG
+	printf("NAND flash probing at 0x%.8lX\n", (ulong)nand);
+#endif
+	printf ("%4lu MB\n", nand_probe((ulong)nand) >> 20);
+}
+#endif
+#endif /*Comment by guowenxue*/
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_CS8900
+	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
+#endif
+#ifdef CONFIG_DRIVER_DM9000 /*Add by guowenxue*/
+    rc = dm9000_initialize(bis);
+#endif
+	return rc;
+}
+#endif
diff -Nuar u-boot-2010.09/boards.cfg u-boot-2010.09-fl2440/boards.cfg
--- u-boot-2010.09/boards.cfg	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/boards.cfg	2013-04-25 17:06:35.288471404 +0800
@@ -238,6 +238,8 @@
 sbc2410x	arm	arm920t		-		-		s3c24x0
 smdk2400	arm	arm920t		-		samsung		s3c24x0
 smdk2410	arm	arm920t		-		samsung		s3c24x0
+sd2410	    arm	arm920t		-		kkernel		s3c24x0
+fl2440	    arm	arm920t		-		kkernel		s3c24x0
 voiceblue	arm	arm925t
 omap1510inn	arm	arm925t		-		ti
 afeb9260	arm	arm926ejs	-		-		at91
diff -Nuar u-boot-2010.09/common/cmd_bootm.c u-boot-2010.09-fl2440/common/cmd_bootm.c
--- u-boot-2010.09/common/cmd_bootm.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/common/cmd_bootm.c	2013-04-25 17:06:35.288471404 +0800
@@ -344,7 +344,7 @@
 		if (load == blob_start) {
 			printf ("   XIP %s ... ", type_name);
 		} else {
-			printf ("   Loading %s ... ", type_name);
+			printf ("   Loading %s from %lx to %lx... ", type_name, image_start, load);
 			memmove_wd ((void *)load, (void *)image_start,
 					image_len, CHUNKSZ);
 		}
@@ -639,6 +639,7 @@
 #endif
 
 	ret = bootm_load_os(images.os, &load_end, 1);
+    printf("OS entry point: %lx\n", images.ep);
 
 	if (ret < 0) {
 		if (ret == BOOTM_ERR_RESET)
diff -Nuar u-boot-2010.09/common/cmd_nand.c u-boot-2010.09-fl2440/common/cmd_nand.c
--- u-boot-2010.09/common/cmd_nand.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/common/cmd_nand.c	2013-04-25 17:06:35.289436811 +0800
@@ -148,6 +148,11 @@
 #if defined(CONFIG_CMD_MTDPARTS)
 out:
 #endif
+    /*Add by guowenxue, if the size is not aligment, then let it's page alignment bug*/
+    if(0 != (*size%nand->writesize)) 
+    {
+        *size = (*size / nand->writesize + 1) * nand->writesize;  
+    }
 	printf("device %d ", idx);
 	if (*size == nand->size)
 		puts("whole chip\n");
diff -Nuar u-boot-2010.09/common/env_common.c u-boot-2010.09-fl2440/common/env_common.c
--- u-boot-2010.09/common/env_common.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/common/env_common.c	2013-05-04 17:22:59.573439003 +0800
@@ -59,6 +59,68 @@
 #ifdef	CONFIG_BOOTCOMMAND
 	"bootcmd="	CONFIG_BOOTCOMMAND		"\0"
 #endif
+/* This part add by guowenxue */
+#ifdef CONFIG_CPU          /* Define CPU information */
+    "cpu=" CONFIG_CPU "\0"
+#endif             
+#ifdef CONFIG_BURNBL       /* Burn bootloader image to Nandflash*/
+    "bbl=" CONFIG_BURNBL "\0"
+#endif              
+#ifdef CONFIG_NORBURNBL    /* Burn bootloader image to Norflash */
+    "norbbl=" CONFIG_NORBURNBL "\0"
+#endif
+#ifdef CONFIG_BURNKERNEL   /* Burn linux kernel image  */
+    "blx=" CONFIG_BURNKERNEL "\0"
+#endif              
+#ifdef CONFIG_BURN_RAMDISK /* Burn Ramdisk root filesystems image */
+    "bramdisk=" CONFIG_BURN_RAMDISK "\0" 
+#endif          
+#ifdef CONFIG_BURN_CRAMFS  /* Burn cramfs root filesystem image  */
+    "bcramfs=" CONFIG_BURN_CRAMFS "\0" 
+#endif
+#ifdef CONFIG_BURN_JFFS2   /* Burn JFFS2 root filesystem image  */
+    "bjffs2=" CONFIG_BURN_JFFS2 "\0" 
+#endif
+#ifdef CONFIG_BURN_YAFFS2  /* Burn YAFFS2 root filesystem image  */
+    "byaffs2=" CONFIG_BURN_YAFFS2 "\0" 
+#endif
+#ifdef CONFIG_BURN_UBIFS   /* Burn UBIFS root filesystems image */
+    "bubifs=" CONFIG_BURN_UBIFS "\0" 
+#endif          
+#ifdef CONFIG_BOOT_RAMDISK /* Boot command for ramdisk filesystem */
+    "bootcmd_ramdisk=" CONFIG_BOOT_RAMDISK "\0"
+#endif              
+#ifdef CONFIG_BOOT_ROOTFS  /* Boot command for root filesystem on mtdblock, such as ubifs,jffs2,yafffs2 */
+    "bootcmd_rootfs=" CONFIG_BOOT_ROOTFS "\0"
+#endif              
+#ifdef CONFIG_TFTPBOOT     /* TFTP download system image and boot */
+    "tb=" CONFIG_TFTPBOOT "\0"
+#endif              
+#ifdef CONFIG_BOOTARGS_INITRAMFS
+	"bootargs_initamfs="	CONFIG_BOOTARGS_INITRAMFS "\0"
+#endif
+#ifdef CONFIG_BOOTARGS_RAMDISK
+	"bootargs_ramdisk="	CONFIG_BOOTARGS_RAMDISK	"\0"
+#endif
+#ifdef CONFIG_BOOTARGS_CRAMFS
+	"bootargs_cramfs="	CONFIG_BOOTARGS_CRAMFS	"\0"
+#endif
+#ifdef CONFIG_BOOTARGS_JFFS2
+	"bootargs_jffs2="	CONFIG_BOOTARGS_JFFS2	"\0"
+#endif
+#ifdef CONFIG_BOOTARGS_YAFFS2
+	"bootargs_yaffs2="	CONFIG_BOOTARGS_YAFFS2	"\0"
+#endif
+#ifdef CONFIG_BOOTARGS_UBIFS
+	"bootargs_ubifs="	CONFIG_BOOTARGS_UBIFS	"\0"
+#endif
+#ifdef MTDIDS_DEFAULT
+	"mtdids="	MTDIDS_DEFAULT	"\0"
+#endif
+#ifdef MTDPARTS_DEFAULT
+	"mtdparts="	MTDPARTS_DEFAULT	"\0"
+#endif
+/* Add by guowenxue end  */
 #ifdef	CONFIG_RAMBOOTCOMMAND
 	"ramboot="	CONFIG_RAMBOOTCOMMAND		"\0"
 #endif
diff -Nuar u-boot-2010.09/common/serial.c u-boot-2010.09-fl2440/common/serial.c
--- u-boot-2010.09/common/serial.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/common/serial.c	2013-04-25 17:06:35.289436811 +0800
@@ -68,7 +68,7 @@
 #else
 #error "Bad CONFIG_PSC_CONSOLE."
 #endif
-#elif defined(CONFIG_S3C2410)
+#elif defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
 #if defined(CONFIG_SERIAL1)
 	return &s3c24xx_serial0_device;
 #elif defined(CONFIG_SERIAL2)
@@ -157,7 +157,7 @@
 #if defined (CONFIG_STUART)
 	serial_register(&serial_stuart_device);
 #endif
-#if defined(CONFIG_S3C2410)
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
 	serial_register(&s3c24xx_serial0_device);
 	serial_register(&s3c24xx_serial1_device);
 	serial_register(&s3c24xx_serial2_device);
diff -Nuar u-boot-2010.09/drivers/i2c/s3c24x0_i2c.c u-boot-2010.09-fl2440/drivers/i2c/s3c24x0_i2c.c
--- u-boot-2010.09/drivers/i2c/s3c24x0_i2c.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/drivers/i2c/s3c24x0_i2c.c	2013-04-25 17:06:35.289436811 +0800
@@ -57,7 +57,7 @@
 {
 	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
 
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440) /*Add CONFIG_S3C2440 by guowenxue*/
 	return (readl(&gpio->GPEDAT) & 0x8000) >> 15;
 #endif
 #ifdef CONFIG_S3C2400
@@ -76,7 +76,7 @@
 {
 	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
 
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 	writel((readl(&gpio->GPEDAT) & ~0x4000) | (x & 1) << 14, &gpio->GPEDAT);
 #endif
 #ifdef CONFIG_S3C2400
@@ -128,7 +128,7 @@
 	}
 
 	if ((readl(&i2c->IICSTAT) & I2CSTAT_BSY) || GetI2CSDA() == 0) {
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 		ulong old_gpecon = readl(&gpio->GPECON);
 #endif
 #ifdef CONFIG_S3C2400
@@ -137,7 +137,7 @@
 		/* bus still busy probably by (most) previously interrupted
 		   transfer */
 
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 		/* set I2CSDA and I2CSCL (GPE15, GPE14) to GPIO */
 		writel((readl(&gpio->GPECON) & ~0xF0000000) | 0x10000000,
 		       &gpio->GPECON);
@@ -163,7 +163,7 @@
 		udelay(1000);
 
 		/* restore pin functions */
-#ifdef CONFIG_S3C2410
+#if defined(CONFIG_S3C2410) || defined (CONFIG_S3C2440)
 		writel(old_gpecon, &gpio->GPECON);
 #endif
 #ifdef CONFIG_S3C2400
diff -Nuar u-boot-2010.09/drivers/mtd/nand/s3c2410_nand.c u-boot-2010.09-fl2440/drivers/mtd/nand/s3c2410_nand.c
--- u-boot-2010.09/drivers/mtd/nand/s3c2410_nand.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/drivers/mtd/nand/s3c2410_nand.c	2013-04-25 17:06:35.290436741 +0800
@@ -24,6 +24,9 @@
 #include <asm/arch/s3c24x0_cpu.h>
 #include <asm/io.h>
 
+#define NF_BASE         0x4e000000
+
+#if defined(CONFIG_S3C2410)
 #define S3C2410_NFCONF_EN          (1<<15)
 #define S3C2410_NFCONF_512BYTE     (1<<14)
 #define S3C2410_NFCONF_4STEP       (1<<13)
@@ -36,6 +39,20 @@
 #define S3C2410_ADDR_NALE 4
 #define S3C2410_ADDR_NCLE 8
 
+#elif defined(CONFIG_S3C2440)
+#define S3C2410_NFCONT_EN          (1<<0)
+#define S3C2410_NFCONT_INITECC     (1<<4)
+#define S3C2410_NFCONT_nFCE        (1<<1)
+#define S3C2410_NFCONT_MAINECCLOCK (1<<5)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<12)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<8)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<4)
+
+#define S3C2410_ADDR_NALE 0x08
+#define S3C2410_ADDR_NCLE 0x0c
+#endif
+ulong IO_ADDR_W = NF_BASE;
+
 #ifdef CONFIG_NAND_SPL
 
 /* in the early stage of NAND flash booting, printf() is not available */
@@ -53,31 +70,37 @@
 
 static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
 {
-	struct nand_chip *chip = mtd->priv;
+//	struct nand_chip *chip = mtd->priv;
 	struct s3c2410_nand *nand = s3c2410_get_base_nand();
 
 	debugX(1, "hwcontrol(): 0x%02x 0x%02x\n", cmd, ctrl);
 
 	if (ctrl & NAND_CTRL_CHANGE) {
-		ulong IO_ADDR_W = (ulong)nand;
+                IO_ADDR_W = (ulong)nand;
 
 		if (!(ctrl & NAND_CLE))
 			IO_ADDR_W |= S3C2410_ADDR_NCLE;
 		if (!(ctrl & NAND_ALE))
 			IO_ADDR_W |= S3C2410_ADDR_NALE;
 
-		chip->IO_ADDR_W = (void *)IO_ADDR_W;
+//		chip->IO_ADDR_W = (void *)IO_ADDR_W;
 
 		if (ctrl & NAND_NCE)
-			writel(readl(&nand->NFCONF) & ~S3C2410_NFCONF_nFCE,
-			       &nand->NFCONF);
+#if defined(CONFIG_S3C2410)
+			writel(readl(&nand->NFCONF) & ~S3C2410_NFCONF_nFCE, &nand->NFCONF);
+#elif defined(CONFIG_S3C2440)
+			writel(readl(&nand->NFCONT) & ~S3C2410_NFCONT_nFCE, &nand->NFCONT);
+#endif
 		else
-			writel(readl(&nand->NFCONF) | S3C2410_NFCONF_nFCE,
-			       &nand->NFCONF);
+#if defined(CONFIG_S3C2410)
+			writel(readl(&nand->NFCONF) | S3C2410_NFCONF_nFCE, &nand->NFCONF);
+#elif defined(CONFIG_S3C2440)
+			writel(readl(&nand->NFCONT) | S3C2410_NFCONT_nFCE, &nand->NFCONT);
+#endif
 	}
 
 	if (cmd != NAND_CMD_NONE)
-		writeb(cmd, chip->IO_ADDR_W);
+                writeb(cmd, (void *)IO_ADDR_W);
 }
 
 static int s3c2410_dev_ready(struct mtd_info *mtd)
@@ -92,7 +115,11 @@
 {
 	struct s3c2410_nand *nand = s3c2410_get_base_nand();
 	debugX(1, "s3c2410_nand_enable_hwecc(%p, %d)\n", mtd, mode);
+#if defined(CONFIG_S3C2410)
 	writel(readl(&nand->NFCONF) | S3C2410_NFCONF_INITECC, &nand->NFCONF);
+#elif defined(CONFIG_S3C2440)
+        writel(readl(&nand->NFCONT) | S3C2410_NFCONT_INITECC, &nand->NFCONT);
+#endif
 }
 
 static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
@@ -132,6 +159,7 @@
 
 	writel(readl(&clk_power->CLKCON) | (1 << 4), &clk_power->CLKCON);
 
+#if defined(CONFIG_S3C2410)
 	/* initialize hardware */
 	twrph0 = 3;
 	twrph1 = 0;
@@ -145,6 +173,22 @@
 
 	/* initialize nand_chip data structure */
 	nand->IO_ADDR_R = nand->IO_ADDR_W = (void *)&nand_reg->NFDATA;
+#elif defined(CONFIG_S3C2440)
+        twrph0 = 4; 
+        twrph1 = 2; 
+        tacls = 0; 
+
+        cfg = 0; 
+        cfg |= S3C2410_NFCONF_TACLS(tacls - 1); 
+        cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1); 
+        cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1); 
+        writel(cfg, &nand_reg->NFCONF); 
+        
+        cfg = (0<<13)|(0<<12)|(0<<10)|(0<<9)|(0<<8)|(0<<6)|(0<<5)|(1<<4)|(0<<1)|(1<<0); 
+        writel(cfg, &nand_reg->NFCONT); 
+        /* initialize nand_chip data structure */ 
+        nand->IO_ADDR_R = nand->IO_ADDR_W = (void *)&nand_reg->NFDATA;
+#endif
 
 	nand->select_chip = NULL;
 
diff -Nuar u-boot-2010.09/drivers/net/dm9000x.c u-boot-2010.09-fl2440/drivers/net/dm9000x.c
--- u-boot-2010.09/drivers/net/dm9000x.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/drivers/net/dm9000x.c	2013-04-25 17:06:35.290436741 +0800
@@ -364,9 +364,10 @@
 	while (!(phy_read(1) & 0x20)) {	/* autonegation complete bit */
 		udelay(1000);
 		i++;
-		if (i == 10000) {
+		if (i == 1000) {
 			printf("could not establish link\n");
-			return 0;
+                        break;
+			//return 0;
 		}
 	}
 
diff -Nuar u-boot-2010.09/include/configs/fl2440.h u-boot-2010.09-fl2440/include/configs/fl2440.h
--- u-boot-2010.09/include/configs/fl2440.h	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/include/configs/fl2440.h	2013-05-04 20:09:23.137439115 +0800
@@ -0,0 +1,305 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Modified for the friendly-arm SBC-2410X by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * Configuation settings for the friendly-arm SBC-2410X board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#undef CONFIG_SKIP_LOWLEVEL_INIT	/* undef for developing */
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T	1	/* This is an ARM920T Core	*/
+#define CONFIG_S3C24X0	1	/* in a SAMSUNG S3C24x0-type SoC	*/
+#define CONFIG_S3C2440      1   /* in a SAMSUNG S3C2440 SoC     */
+#define CONFIG_MINI2440     1   /* FL2440 is copy from friendly-arm MINI2440 Board */
+
+#define CONFIG_FL2440_LED               1
+#define CONFIG_FL2440_BEEP              1
+#define CONFIG_S3C2410_NAND_SKIP_BAD    1
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000/* the SBC2410X has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+
+//#define CONFIG_USB_DEVICE 1
+#ifdef CONFIG_USB_DEVICE          /*Add USB device support by guowenxue*/
+#define CONFIG_USE_IRQ 1
+#endif
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 512*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#if 0  /* Comment by guowenxue, not CS8900 but DM9000 on my board*/
+#define CONFIG_NET_MULTI
+#define CONFIG_CS8900		/* we have a CS8900 on-board */
+#define CONFIG_CS8900_BASE	0x19000300
+#define CONFIG_CS8900_BUS16	/* the Linux driver does accesses as shorts */
+#endif
+#define CONFIG_NET_MULTI            1
+#define CONFIG_NET_RETRY_COUNT      20
+#define CONFIG_DRIVER_DM9000        1
+#define CONFIG_DM9000_BASE          0x20000300  /* nGCS4*/
+#define DM9000_IO                   CONFIG_DM9000_BASE
+#define DM9000_DATA                 (CONFIG_DM9000_BASE+4)
+#define CONFIG_DM9000_USE_16BIT     1
+#define CONFIG_DM9000_NO_SROM       1
+#undef CONFIG_DM9000_DEBUG
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24X0_SERIAL
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SBC2410X */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NAND
+
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_CPU          "s3c2440"
+
+#define CONFIG_ETHADDR	    08:00:3e:26:0a:6b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		192.168.1.244
+#define CONFIG_SERVERIP		192.168.1.2
+
+/* Burn bootloader, linux kernel and rootfs command */
+#define CONFIG_BURNBL       "tftp 30008000 u-boot-$cpu.bin;nand erase 0 100000;nand write 30008000 0 $filesize"
+#define CONFIG_NORBURNBL    "erase bank 1; tftp 30008000 u-boot-$cpu.bin;cp.b 30008000 0 $filesize"
+#define CONFIG_BURNKERNEL   "tftp 30008000 linuxrom-$cpu.bin;nand erase 100000 F00000;nand write 30008000 100000 $filesize"
+#define CONFIG_BURN_RAMDISK "tftp 30800000 ramdisk-$cpu.rootfs;nand erase 1000000 1400000;nand write 30800000 1000000 $filesize"
+#define CONFIG_BURN_CRAMFS  "tftp 30800000 cramfs-$cpu.rootfs;nand erase 2400000 1400000;nand write 30800000 2400000 $filesize"
+#define CONFIG_BURN_JFFS2   "tftp 30800000 jffs2-$cpu.rootfs;nand erase 3800000 2800000;nand write 30800000 3800000 $filesize"
+#define CONFIG_BURN_YAFFS2  "tftp 30800000 yaffs2-$cpu.rootfs;nand erase 6000000 2800000;nand write 30800000 6000000 $filesize"
+#define CONFIG_BURN_UBIFS   "tftp 30800000 ubifs-$cpu.rootfs;nand erase 8800000 2800000;nand write 30800000 8800000 $filesize"
+
+/* Ramdisk rootfs boot command  */
+#define CONFIG_BOOT_RAMDISK "nand read 30008000 100000 F00000;nand read 30800000 1000000 1400000;bootm 30008000"
+/* Cramfs,jffs2,yaffs2,ubifs boot command  */
+#define CONFIG_BOOT_ROOTFS  "nand read 30008000 100000 F00000;bootm 30008000"
+/* tftp boot command */
+#define CONFIG_TFTPBOOT     "tftp 30008000 linuxrom-$cpu.bin;bootm 30008000 "
+#define CONFIG_BOOTCOMMAND  CONFIG_BOOT_ROOTFS 
+
+/* Bootargs for different root filesystem */
+#define CONFIG_BOOTARGS_INITRAMFS	"console=ttyS0,115200 mem=64M rw loglevel=7"
+#define CONFIG_BOOTARGS_RAMDISK	"console=ttyS0,115200 root=/dev/ram0 initrd=0x30800000,16M init=/linuxrc mem=64M rw loglevel=7"
+#define CONFIG_BOOTARGS_CRAMFS "console=ttyS0,115200 root=/dev/mtdblock3 rootfstype=cramfs init=/linuxrc mem=64M noinitrd loglevel=7"
+#define CONFIG_BOOTARGS_JFFS2 "console=ttyS0,115200 root=/dev/mtdblock4 rootfstype=jffs2 init=/linuxrc mem=64M rw noinitrd loglevel=7"
+#define CONFIG_BOOTARGS_UBIFS "console=ttyS0,115200 ubi.mtd=6 root=ubi0:rootfs rootwait rootfstype=ubifs init=/linuxrc mem=64M noinitrd rw loglevel=7"
+#define CONFIG_BOOTARGS		CONFIG_BOOTARGS_INITRAMFS
+
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+#define	CONFIG_SYS_PROMPT		"[ s3c2440@guowenxue ]# "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#define	CONFIG_SYS_LOAD_ADDR		0x33000000	/* default load address	*/
+
+#define	CONFIG_SYS_HZ			1000
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #0 */
+
+/*  Flash Bank #1, when we jump the J2 to 1 on FL2440, the norflash will connect to nGCS1 */
+//#define PHYS_FLASH_1		0x08000000 
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define FLASH_BASE0_PRELIM  PHYS_FLASH_1 
+#define CONFIG_SYS_MONITOR_BASE TEXT_BASE
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+/* #define CONFIG_AMD_LV400	1	/\* uncomment this if you have a LV400 flash *\/ */
+
+//#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CONFIG_INTEL_JS28F320 1
+
+#ifdef CONFIG_INTEL_JS28F320
+#define PHYS_FLASH_SIZE 0x400000   /*  4M */
+#define CONFIG_SYS_MAX_FLASH_SECT 32
+#define CONFIG_ENV_ADDR         (CONFIG_SYS_FLASH_BASE + 0x40000)
+#endif
+
+
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(8*CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(8*CONFIG_SYS_HZ) /* Timeout for Flash Write */
+
+//#define	CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_IS_IN_NAND   1
+#define CONFIG_ENV_OFFSET       0X60000
+#define CONFIG_ENV_SIZE         0x20000 /* Total Size of Environment Sector */
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#if defined(CONFIG_CMD_NAND)
+#define CONFIG_NAND_S3C2410
+#define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices		*/
+#define CONFIG_SYS_NAND_BASE 0x4E000000 
+#define SECTORSIZE 512
+#define SECTORSIZE_2K 2048
+#define NAND_SECTOR_SIZE SECTORSIZE
+#define NAND_SECTOR_SIZE_2K SECTORSIZE_2K
+#define NAND_BLOCK_MASK 511
+#define NAND_BLOCK_MASK_2K 2047
+#define NAND_MAX_CHIPS 1
+#define CONFIG_MTD_NAND_VERIFY_WRITE 
+#define CONFIG_SYS_64BIT_VSPRINTF       /* needed for nand_util.c */
+#endif	/* CONFIG_CMD_NAND */
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_TAG
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2   "> "
+
+//#define CONFIG_CMDLINE_EDITING
+
+#ifdef CONFIG_CMDLINE_EDITING
+#undef CONFIG_AUTO_COMPLETE
+#else
+#define CONFIG_AUTO_COMPLETE
+#endif
+
+/*For UBIFS file system, add by guowenxue  */
+#define CONFIG_CMD_UBI
+#define CONFIG_CMD_UBIFS
+
+#define CONFIG_RBTREE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_LZO
+#define CONFIG_MTD_DEVICE       /*  needed for mtdparts commands */
+
+#define MTDIDS_DEFAULT "nand0=nand0"
+#define MTDPARTS_DEFAULT "mtdparts=nand0:1m(uboot),15m(kernel),20m(ramdisk),20m(cramfs),20m(jffs2),20m(yaffs2),20m(ubifs),-(users)"
+#define MTD_ACTIVE_PART "nand0,6"
+
+
+#endif	/* __CONFIG_H */
diff -Nuar u-boot-2010.09/include/configs/sd2410.h u-boot-2010.09-fl2440/include/configs/sd2410.h
--- u-boot-2010.09/include/configs/sd2410.h	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2010.09-fl2440/include/configs/sd2410.h	2013-04-25 17:06:35.291436812 +0800
@@ -0,0 +1,261 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Modified for the friendly-arm SBC-2410X by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * Configuation settings for the friendly-arm SBC-2410X board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+#undef CONFIG_SKIP_LOWLEVEL_INIT	/* undef for developing */
+//#define CONFIG_SKIP_LOWLEVEL_INIT   /*  Running in RAM for debug*/
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T	1	/* This is an ARM920T Core	*/
+#define CONFIG_S3C24X0	1	/* in a SAMSUNG S3C24x0-type SoC	*/
+#define CONFIG_S3C2410	1	/* specifically a SAMSUNG S3C2410 SoC	*/
+#define CONFIG_SD2410	1	/* on a GuangZhou Sidao SD-2410x Board, copy from sbc2410x.h */
+//#define CONFIG_S3C2410_NAND_SKIP_BAD    1
+
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000/* the SBC2410X has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#if 0  /* Comment by guowenxue, not CS8900 but DM9000 on my board*/
+#define CONFIG_NET_MULTI
+#define CONFIG_CS8900		/* we have a CS8900 on-board */
+#define CONFIG_CS8900_BASE	0x19000300
+#define CONFIG_CS8900_BUS16	/* the Linux driver does accesses as shorts */
+#endif
+#define CONFIG_NET_MULTI            1
+#define CONFIG_NET_RETRY_COUNT      20
+#define CONFIG_DRIVER_DM9000        1
+#define CONFIG_DM9000_BASE          0x18000300  /* nGCS3*/
+#define DM9000_IO                   CONFIG_DM9000_BASE
+#define DM9000_DATA                 (CONFIG_DM9000_BASE+4)
+#define CONFIG_DM9000_USE_16BIT     1
+#define CONFIG_DM9000_NO_SROM       1
+#undef CONFIG_DM9000_DEBUG
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24X0_SERIAL
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SBC2410X */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NAND
+
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_CPU          "s3c2410"
+
+#define CONFIG_ETHADDR	    08:00:3e:26:0a:7b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		192.168.1.241
+#define CONFIG_SERVERIP		192.168.1.78
+
+#define CONFIG_BURNBL       "nand erase 0 50000;tftp 30008000 u-boot-$cpu.bin;nand write 30008000 0 40000"
+#define CONFIG_BURNKERNEL   "tftp 30008000 uImage-$cpu.gz;nand erase 100000 300000;nand write 30008000 100000 300000 "
+#define CONFIG_BURN_RAMDISK "tftp 30800000 ramdisk-$cpu.gz;nand erase 400000 600000;nand write 30800000 400000 600000 "
+#define CONFIG_BURN_UBIFS   "tftp 30800000 ubifs-$cpu.img;nand erase 0x02e00000 0x01400000;" \
+                                "nand write 0x30800000 0x2e00000 0x4c0000"
+
+#define CONFIG_BOOT_RAMDISK "nand read 30008000 100000 300000;nand read 30800000 400000 600000;bootm 30008000"
+#define CONFIG_BOOT_ROOTFS  "nand read 30008000 100000 300000;bootm 30008000"
+#define CONFIG_TFTPBOOT     "tftp 30008000 uImage-$cpu.gz;tftp 30800000 ramdisk-$cpu.gz;bootm 30008000 "
+#define CONFIG_BOOTCOMMAND  "run bootcmd_ramdisk"   /*  Or bootcmd_rootfs for jffs2,ubifs,yaffs2 */
+
+#define CONFIG_BOOTARGS_RAMDISK	"console=ttyS0,115200 mem=64M initrd=0x30800000,16M root=/dev/ram0 rw loglevel=7 "
+#define CONFIG_BOOTARGS_UBIFS   "console=ttyS0,115200 mem=64M ubi.mtd=5 root=ubi0:rootfs rootwait rootfstype=ubifs rw"
+#define CONFIG_BOOTARGS         CONFIG_BOOTARGS_RAMDISK
+
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+#define	CONFIG_SYS_PROMPT		"[ s3c2410@guowenxue ]# "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#define	CONFIG_SYS_LOAD_ADDR		0x33000000	/* default load address	*/
+
+#define	CONFIG_SYS_HZ			1000
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+/* #define CONFIG_AMD_LV400	1	/\* uncomment this if you have a LV400 flash *\/ */
+
+#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ) /* Timeout for Flash Write */
+
+//#define	CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_IS_IN_NAND   1
+#define CONFIG_ENV_OFFSET       0X60000
+#define CONFIG_ENV_SIZE         0x20000 /* Total Size of Environment Sector */
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#if defined(CONFIG_CMD_NAND)
+#define CONFIG_NAND_S3C2410
+#define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices		*/
+#define CONFIG_SYS_NAND_BASE 0x4E000000 
+#define SECTORSIZE 512
+#define SECTORSIZE_2K 2048
+#define NAND_SECTOR_SIZE SECTORSIZE
+#define NAND_SECTOR_SIZE_2K SECTORSIZE_2K
+#define NAND_BLOCK_MASK 511
+#define NAND_BLOCK_MASK_2K 2047
+#define NAND_MAX_CHIPS 1
+#define CONFIG_MTD_NAND_VERIFY_WRITE 
+#define CONFIG_SYS_64BIT_VSPRINTF       /* needed for nand_util.c */
+#endif	/* CONFIG_CMD_NAND */
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_TAG
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2   "> "
+
+//#define CONFIG_CMDLINE_EDITING
+
+#ifdef CONFIG_CMDLINE_EDITING
+#undef CONFIG_AUTO_COMPLETE
+#else
+#define CONFIG_AUTO_COMPLETE
+#endif
+
+#endif	/* __CONFIG_H */
diff -Nuar u-boot-2010.09/include/serial.h u-boot-2010.09-fl2440/include/serial.h
--- u-boot-2010.09/include/serial.h	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/include/serial.h	2013-04-25 17:06:35.291436812 +0800
@@ -46,7 +46,7 @@
 extern struct serial_device serial6_device;
 #endif
 
-#if defined(CONFIG_S3C2410)
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
 extern struct serial_device s3c24xx_serial0_device;
 extern struct serial_device s3c24xx_serial1_device;
 extern struct serial_device s3c24xx_serial2_device;
diff -Nuar u-boot-2010.09/Makefile u-boot-2010.09-fl2440/Makefile
--- u-boot-2010.09/Makefile	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/Makefile	2013-04-25 17:06:35.292436893 +0800
@@ -154,6 +154,7 @@
 # load ARCH, BOARD, and CPU configuration
 include $(obj)include/config.mk
 export	ARCH CPU BOARD VENDOR SOC
+CROSS_COMPILE = /opt/buildroot-2012.08/arm920t/usr/bin/arm-linux-
 
 # set default to nothing for native builds
 ifeq ($(HOSTARCH),$(ARCH))
@@ -307,7 +308,8 @@
 # Always append ALL so that arch config.mk's can add custom ones
 ALL += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND) $(U_BOOT_ONENAND)
 
-all:		$(ALL)
+all:		$(ALL) 
+		cp u-boot.bin u-boot-s3c2440.bin 
 
 $(obj)u-boot.hex:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
@@ -2438,6 +2440,16 @@
 #########################################################################
 #########################################################################
 
+uninstall:
+	rm -f /tftp/u-boot-s3c2440.bin
+
+install: uninstall
+	cp u-boot-s3c2440.bin /tftp
+
+tag:
+	@cscope -Rbq
+	@ctags --c-kinds=+defglmnstuvx --langmap=c:.c.h.ho.hem.het.hec.hev.him.hit.hic.hiv -R .
+
 clean:
 	@rm -f $(obj)examples/standalone/82559_eeprom			  \
 	       $(obj)examples/standalone/atmel_df_pow2			  \
diff -Nuar u-boot-2010.09/net/nfs.c u-boot-2010.09-fl2440/net/nfs.c
--- u-boot-2010.09/net/nfs.c	2010-09-29 05:20:55.000000000 +0800
+++ u-boot-2010.09-fl2440/net/nfs.c	2013-04-25 17:06:35.293436809 +0800
@@ -31,7 +31,7 @@
 
 #define HASHES_PER_LINE 65	/* Number of "loading" hashes per line	*/
 #define NFS_RETRY_COUNT 30
-#define NFS_TIMEOUT 2000UL
+#define NFS_TIMEOUT (10*2000UL)
 
 static int fs_mounted = 0;
 static unsigned long rpc_id = 0;
